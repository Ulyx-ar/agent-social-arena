{"version":3,"sources":["../../src/generated/types/authorized.ts","../../src/generated/types/delegation.ts","../../src/generated/types/lockup.ts","../../src/generated/types/meta.ts","../../src/generated/types/stake.ts","../../src/generated/types/stakeAuthorize.ts","../../src/generated/types/stakeFlags.ts","../../src/generated/types/stakeState.ts","../../src/generated/types/stakeStateV2.ts","../../src/generated/accounts/stakeStateAccount.ts","../../src/generated/programs/stake.ts","../../src/generated/errors/stake.ts","../../src/generated/shared/index.ts","../../src/generated/instructions/authorize.ts","../../src/generated/instructions/authorizeChecked.ts","../../src/generated/instructions/authorizeCheckedWithSeed.ts","../../src/generated/instructions/authorizeWithSeed.ts","../../src/generated/instructions/deactivate.ts","../../src/generated/instructions/deactivateDelinquent.ts","../../src/generated/instructions/delegateStake.ts","../../src/generated/instructions/getMinimumDelegation.ts","../../src/generated/instructions/initialize.ts","../../src/generated/instructions/initializeChecked.ts","../../src/generated/instructions/merge.ts","../../src/generated/instructions/moveLamports.ts","../../src/generated/instructions/moveStake.ts","../../src/generated/instructions/setLockup.ts","../../src/generated/instructions/setLockupChecked.ts","../../src/generated/instructions/split.ts","../../src/generated/instructions/withdraw.ts"],"names":["getStructEncoder","getAddressEncoder","getStructDecoder","getAddressDecoder","combineCodec","getU64Encoder","getU64Decoder","StakeAuthorize","getDiscriminatedUnionEncoder","getUnitEncoder","getTupleEncoder","getU32Encoder","getDiscriminatedUnionDecoder","getUnitDecoder","getTupleDecoder","getU32Decoder","StakeAccount","StakeInstruction","kitIsTransactionSigner","transformEncoder","addEncoderSizePrefix","getUtf8Encoder","addDecoderSizePrefix","getUtf8Decoder","getI64Encoder","getI64Decoder","getOptionEncoder","getOptionDecoder"],"mappings":"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","file":"index.mjs","sourcesContent":["/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n} from '@solana/kit';\n\nexport type Authorized = { staker: Address; withdrawer: Address };\n\nexport type AuthorizedArgs = Authorized;\n\nexport function getAuthorizedEncoder(): FixedSizeEncoder<AuthorizedArgs> {\n  return getStructEncoder([\n    ['staker', getAddressEncoder()],\n    ['withdrawer', getAddressEncoder()],\n  ]);\n}\n\nexport function getAuthorizedDecoder(): FixedSizeDecoder<Authorized> {\n  return getStructDecoder([\n    ['staker', getAddressDecoder()],\n    ['withdrawer', getAddressDecoder()],\n  ]);\n}\n\nexport function getAuthorizedCodec(): FixedSizeCodec<\n  AuthorizedArgs,\n  Authorized\n> {\n  return combineCodec(getAuthorizedEncoder(), getAuthorizedDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getF64Decoder,\n  getF64Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n} from '@solana/kit';\n\nexport type Delegation = {\n  voterPubkey: Address;\n  stake: bigint;\n  activationEpoch: bigint;\n  deactivationEpoch: bigint;\n  warmupCooldownRate: number;\n};\n\nexport type DelegationArgs = {\n  voterPubkey: Address;\n  stake: number | bigint;\n  activationEpoch: number | bigint;\n  deactivationEpoch: number | bigint;\n  warmupCooldownRate: number;\n};\n\nexport function getDelegationEncoder(): FixedSizeEncoder<DelegationArgs> {\n  return getStructEncoder([\n    ['voterPubkey', getAddressEncoder()],\n    ['stake', getU64Encoder()],\n    ['activationEpoch', getU64Encoder()],\n    ['deactivationEpoch', getU64Encoder()],\n    ['warmupCooldownRate', getF64Encoder()],\n  ]);\n}\n\nexport function getDelegationDecoder(): FixedSizeDecoder<Delegation> {\n  return getStructDecoder([\n    ['voterPubkey', getAddressDecoder()],\n    ['stake', getU64Decoder()],\n    ['activationEpoch', getU64Decoder()],\n    ['deactivationEpoch', getU64Decoder()],\n    ['warmupCooldownRate', getF64Decoder()],\n  ]);\n}\n\nexport function getDelegationCodec(): FixedSizeCodec<\n  DelegationArgs,\n  Delegation\n> {\n  return combineCodec(getDelegationEncoder(), getDelegationDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getI64Decoder,\n  getI64Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n} from '@solana/kit';\n\nexport type Lockup = {\n  unixTimestamp: bigint;\n  epoch: bigint;\n  custodian: Address;\n};\n\nexport type LockupArgs = {\n  unixTimestamp: number | bigint;\n  epoch: number | bigint;\n  custodian: Address;\n};\n\nexport function getLockupEncoder(): FixedSizeEncoder<LockupArgs> {\n  return getStructEncoder([\n    ['unixTimestamp', getI64Encoder()],\n    ['epoch', getU64Encoder()],\n    ['custodian', getAddressEncoder()],\n  ]);\n}\n\nexport function getLockupDecoder(): FixedSizeDecoder<Lockup> {\n  return getStructDecoder([\n    ['unixTimestamp', getI64Decoder()],\n    ['epoch', getU64Decoder()],\n    ['custodian', getAddressDecoder()],\n  ]);\n}\n\nexport function getLockupCodec(): FixedSizeCodec<LockupArgs, Lockup> {\n  return combineCodec(getLockupEncoder(), getLockupDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n} from '@solana/kit';\nimport {\n  getAuthorizedDecoder,\n  getAuthorizedEncoder,\n  getLockupDecoder,\n  getLockupEncoder,\n  type Authorized,\n  type AuthorizedArgs,\n  type Lockup,\n  type LockupArgs,\n} from '.';\n\nexport type Meta = {\n  rentExemptReserve: bigint;\n  authorized: Authorized;\n  lockup: Lockup;\n};\n\nexport type MetaArgs = {\n  rentExemptReserve: number | bigint;\n  authorized: AuthorizedArgs;\n  lockup: LockupArgs;\n};\n\nexport function getMetaEncoder(): FixedSizeEncoder<MetaArgs> {\n  return getStructEncoder([\n    ['rentExemptReserve', getU64Encoder()],\n    ['authorized', getAuthorizedEncoder()],\n    ['lockup', getLockupEncoder()],\n  ]);\n}\n\nexport function getMetaDecoder(): FixedSizeDecoder<Meta> {\n  return getStructDecoder([\n    ['rentExemptReserve', getU64Decoder()],\n    ['authorized', getAuthorizedDecoder()],\n    ['lockup', getLockupDecoder()],\n  ]);\n}\n\nexport function getMetaCodec(): FixedSizeCodec<MetaArgs, Meta> {\n  return combineCodec(getMetaEncoder(), getMetaDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n} from '@solana/kit';\nimport {\n  getDelegationDecoder,\n  getDelegationEncoder,\n  type Delegation,\n  type DelegationArgs,\n} from '.';\n\nexport type Stake = { delegation: Delegation; creditsObserved: bigint };\n\nexport type StakeArgs = {\n  delegation: DelegationArgs;\n  creditsObserved: number | bigint;\n};\n\nexport function getStakeEncoder(): FixedSizeEncoder<StakeArgs> {\n  return getStructEncoder([\n    ['delegation', getDelegationEncoder()],\n    ['creditsObserved', getU64Encoder()],\n  ]);\n}\n\nexport function getStakeDecoder(): FixedSizeDecoder<Stake> {\n  return getStructDecoder([\n    ['delegation', getDelegationDecoder()],\n    ['creditsObserved', getU64Decoder()],\n  ]);\n}\n\nexport function getStakeCodec(): FixedSizeCodec<StakeArgs, Stake> {\n  return combineCodec(getStakeEncoder(), getStakeDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n} from '@solana/kit';\n\nexport enum StakeAuthorize {\n  Staker,\n  Withdrawer,\n}\n\nexport type StakeAuthorizeArgs = StakeAuthorize;\n\nexport function getStakeAuthorizeEncoder(): FixedSizeEncoder<StakeAuthorizeArgs> {\n  return getEnumEncoder(StakeAuthorize);\n}\n\nexport function getStakeAuthorizeDecoder(): FixedSizeDecoder<StakeAuthorize> {\n  return getEnumDecoder(StakeAuthorize);\n}\n\nexport function getStakeAuthorizeCodec(): FixedSizeCodec<\n  StakeAuthorizeArgs,\n  StakeAuthorize\n> {\n  return combineCodec(getStakeAuthorizeEncoder(), getStakeAuthorizeDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n} from '@solana/kit';\n\nexport type StakeFlags = { bits: number };\n\nexport type StakeFlagsArgs = StakeFlags;\n\nexport function getStakeFlagsEncoder(): FixedSizeEncoder<StakeFlagsArgs> {\n  return getStructEncoder([['bits', getU8Encoder()]]);\n}\n\nexport function getStakeFlagsDecoder(): FixedSizeDecoder<StakeFlags> {\n  return getStructDecoder([['bits', getU8Decoder()]]);\n}\n\nexport function getStakeFlagsCodec(): FixedSizeCodec<\n  StakeFlagsArgs,\n  StakeFlags\n> {\n  return combineCodec(getStakeFlagsEncoder(), getStakeFlagsDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getDiscriminatedUnionDecoder,\n  getDiscriminatedUnionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getTupleDecoder,\n  getTupleEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getUnitDecoder,\n  getUnitEncoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type GetDiscriminatedUnionVariant,\n  type GetDiscriminatedUnionVariantContent,\n} from '@solana/kit';\nimport {\n  getMetaDecoder,\n  getMetaEncoder,\n  getStakeDecoder,\n  getStakeEncoder,\n  type Meta,\n  type MetaArgs,\n  type Stake,\n  type StakeArgs,\n} from '.';\n\nexport type StakeState =\n  | { __kind: 'Uninitialized' }\n  | { __kind: 'Initialized'; fields: readonly [Meta] }\n  | { __kind: 'Stake'; fields: readonly [Meta, Stake] }\n  | { __kind: 'RewardsPool' };\n\nexport type StakeStateArgs =\n  | { __kind: 'Uninitialized' }\n  | { __kind: 'Initialized'; fields: readonly [MetaArgs] }\n  | { __kind: 'Stake'; fields: readonly [MetaArgs, StakeArgs] }\n  | { __kind: 'RewardsPool' };\n\nexport function getStakeStateEncoder(): Encoder<StakeStateArgs> {\n  return getDiscriminatedUnionEncoder(\n    [\n      ['Uninitialized', getUnitEncoder()],\n      [\n        'Initialized',\n        getStructEncoder([['fields', getTupleEncoder([getMetaEncoder()])]]),\n      ],\n      [\n        'Stake',\n        getStructEncoder([\n          ['fields', getTupleEncoder([getMetaEncoder(), getStakeEncoder()])],\n        ]),\n      ],\n      ['RewardsPool', getUnitEncoder()],\n    ],\n    { size: getU32Encoder() }\n  );\n}\n\nexport function getStakeStateDecoder(): Decoder<StakeState> {\n  return getDiscriminatedUnionDecoder(\n    [\n      ['Uninitialized', getUnitDecoder()],\n      [\n        'Initialized',\n        getStructDecoder([['fields', getTupleDecoder([getMetaDecoder()])]]),\n      ],\n      [\n        'Stake',\n        getStructDecoder([\n          ['fields', getTupleDecoder([getMetaDecoder(), getStakeDecoder()])],\n        ]),\n      ],\n      ['RewardsPool', getUnitDecoder()],\n    ],\n    { size: getU32Decoder() }\n  );\n}\n\nexport function getStakeStateCodec(): Codec<StakeStateArgs, StakeState> {\n  return combineCodec(getStakeStateEncoder(), getStakeStateDecoder());\n}\n\n// Data Enum Helpers.\nexport function stakeState(\n  kind: 'Uninitialized'\n): GetDiscriminatedUnionVariant<StakeStateArgs, '__kind', 'Uninitialized'>;\nexport function stakeState(\n  kind: 'Initialized',\n  data: GetDiscriminatedUnionVariantContent<\n    StakeStateArgs,\n    '__kind',\n    'Initialized'\n  >['fields']\n): GetDiscriminatedUnionVariant<StakeStateArgs, '__kind', 'Initialized'>;\nexport function stakeState(\n  kind: 'Stake',\n  data: GetDiscriminatedUnionVariantContent<\n    StakeStateArgs,\n    '__kind',\n    'Stake'\n  >['fields']\n): GetDiscriminatedUnionVariant<StakeStateArgs, '__kind', 'Stake'>;\nexport function stakeState(\n  kind: 'RewardsPool'\n): GetDiscriminatedUnionVariant<StakeStateArgs, '__kind', 'RewardsPool'>;\nexport function stakeState<K extends StakeStateArgs['__kind'], Data>(\n  kind: K,\n  data?: Data\n) {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isStakeState<K extends StakeState['__kind']>(\n  kind: K,\n  value: StakeState\n): value is StakeState & { __kind: K } {\n  return value.__kind === kind;\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getDiscriminatedUnionDecoder,\n  getDiscriminatedUnionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getTupleDecoder,\n  getTupleEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getUnitDecoder,\n  getUnitEncoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type GetDiscriminatedUnionVariant,\n  type GetDiscriminatedUnionVariantContent,\n} from '@solana/kit';\nimport {\n  getMetaDecoder,\n  getMetaEncoder,\n  getStakeDecoder,\n  getStakeEncoder,\n  getStakeFlagsDecoder,\n  getStakeFlagsEncoder,\n  type Meta,\n  type MetaArgs,\n  type Stake,\n  type StakeArgs,\n  type StakeFlags,\n  type StakeFlagsArgs,\n} from '.';\n\nexport type StakeStateV2 =\n  | { __kind: 'Uninitialized' }\n  | { __kind: 'Initialized'; fields: readonly [Meta] }\n  | { __kind: 'Stake'; fields: readonly [Meta, Stake, StakeFlags] }\n  | { __kind: 'RewardsPool' };\n\nexport type StakeStateV2Args =\n  | { __kind: 'Uninitialized' }\n  | { __kind: 'Initialized'; fields: readonly [MetaArgs] }\n  | { __kind: 'Stake'; fields: readonly [MetaArgs, StakeArgs, StakeFlagsArgs] }\n  | { __kind: 'RewardsPool' };\n\nexport function getStakeStateV2Encoder(): Encoder<StakeStateV2Args> {\n  return getDiscriminatedUnionEncoder(\n    [\n      ['Uninitialized', getUnitEncoder()],\n      [\n        'Initialized',\n        getStructEncoder([['fields', getTupleEncoder([getMetaEncoder()])]]),\n      ],\n      [\n        'Stake',\n        getStructEncoder([\n          [\n            'fields',\n            getTupleEncoder([\n              getMetaEncoder(),\n              getStakeEncoder(),\n              getStakeFlagsEncoder(),\n            ]),\n          ],\n        ]),\n      ],\n      ['RewardsPool', getUnitEncoder()],\n    ],\n    { size: getU32Encoder() }\n  );\n}\n\nexport function getStakeStateV2Decoder(): Decoder<StakeStateV2> {\n  return getDiscriminatedUnionDecoder(\n    [\n      ['Uninitialized', getUnitDecoder()],\n      [\n        'Initialized',\n        getStructDecoder([['fields', getTupleDecoder([getMetaDecoder()])]]),\n      ],\n      [\n        'Stake',\n        getStructDecoder([\n          [\n            'fields',\n            getTupleDecoder([\n              getMetaDecoder(),\n              getStakeDecoder(),\n              getStakeFlagsDecoder(),\n            ]),\n          ],\n        ]),\n      ],\n      ['RewardsPool', getUnitDecoder()],\n    ],\n    { size: getU32Decoder() }\n  );\n}\n\nexport function getStakeStateV2Codec(): Codec<StakeStateV2Args, StakeStateV2> {\n  return combineCodec(getStakeStateV2Encoder(), getStakeStateV2Decoder());\n}\n\n// Data Enum Helpers.\nexport function stakeStateV2(\n  kind: 'Uninitialized'\n): GetDiscriminatedUnionVariant<StakeStateV2Args, '__kind', 'Uninitialized'>;\nexport function stakeStateV2(\n  kind: 'Initialized',\n  data: GetDiscriminatedUnionVariantContent<\n    StakeStateV2Args,\n    '__kind',\n    'Initialized'\n  >['fields']\n): GetDiscriminatedUnionVariant<StakeStateV2Args, '__kind', 'Initialized'>;\nexport function stakeStateV2(\n  kind: 'Stake',\n  data: GetDiscriminatedUnionVariantContent<\n    StakeStateV2Args,\n    '__kind',\n    'Stake'\n  >['fields']\n): GetDiscriminatedUnionVariant<StakeStateV2Args, '__kind', 'Stake'>;\nexport function stakeStateV2(\n  kind: 'RewardsPool'\n): GetDiscriminatedUnionVariant<StakeStateV2Args, '__kind', 'RewardsPool'>;\nexport function stakeStateV2<K extends StakeStateV2Args['__kind'], Data>(\n  kind: K,\n  data?: Data\n) {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isStakeStateV2<K extends StakeStateV2['__kind']>(\n  kind: K,\n  value: StakeStateV2\n): value is StakeStateV2 & { __kind: K } {\n  return value.__kind === kind;\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  getStructDecoder,\n  getStructEncoder,\n  type Account,\n  type Address,\n  type Codec,\n  type Decoder,\n  type EncodedAccount,\n  type Encoder,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n} from '@solana/kit';\nimport {\n  getStakeStateV2Decoder,\n  getStakeStateV2Encoder,\n  type StakeStateV2,\n  type StakeStateV2Args,\n} from '../types';\n\nexport type StakeStateAccount = { state: StakeStateV2 };\n\nexport type StakeStateAccountArgs = { state: StakeStateV2Args };\n\nexport function getStakeStateAccountEncoder(): Encoder<StakeStateAccountArgs> {\n  return getStructEncoder([['state', getStakeStateV2Encoder()]]);\n}\n\nexport function getStakeStateAccountDecoder(): Decoder<StakeStateAccount> {\n  return getStructDecoder([['state', getStakeStateV2Decoder()]]);\n}\n\nexport function getStakeStateAccountCodec(): Codec<\n  StakeStateAccountArgs,\n  StakeStateAccount\n> {\n  return combineCodec(\n    getStakeStateAccountEncoder(),\n    getStakeStateAccountDecoder()\n  );\n}\n\nexport function decodeStakeStateAccount<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<StakeStateAccount, TAddress>;\nexport function decodeStakeStateAccount<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<StakeStateAccount, TAddress>;\nexport function decodeStakeStateAccount<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n):\n  | Account<StakeStateAccount, TAddress>\n  | MaybeAccount<StakeStateAccount, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getStakeStateAccountDecoder()\n  );\n}\n\nexport async function fetchStakeStateAccount<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<StakeStateAccount, TAddress>> {\n  const maybeAccount = await fetchMaybeStakeStateAccount(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeStakeStateAccount<\n  TAddress extends string = string,\n>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<StakeStateAccount, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeStakeStateAccount(maybeAccount);\n}\n\nexport async function fetchAllStakeStateAccount(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<StakeStateAccount>[]> {\n  const maybeAccounts = await fetchAllMaybeStakeStateAccount(\n    rpc,\n    addresses,\n    config\n  );\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeStakeStateAccount(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<StakeStateAccount>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) =>\n    decodeStakeStateAccount(maybeAccount)\n  );\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  containsBytes,\n  getU32Encoder,\n  type Address,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  type ParsedAuthorizeCheckedInstruction,\n  type ParsedAuthorizeCheckedWithSeedInstruction,\n  type ParsedAuthorizeInstruction,\n  type ParsedAuthorizeWithSeedInstruction,\n  type ParsedDeactivateDelinquentInstruction,\n  type ParsedDeactivateInstruction,\n  type ParsedDelegateStakeInstruction,\n  type ParsedGetMinimumDelegationInstruction,\n  type ParsedInitializeCheckedInstruction,\n  type ParsedInitializeInstruction,\n  type ParsedMergeInstruction,\n  type ParsedMoveLamportsInstruction,\n  type ParsedMoveStakeInstruction,\n  type ParsedSetLockupCheckedInstruction,\n  type ParsedSetLockupInstruction,\n  type ParsedSplitInstruction,\n  type ParsedWithdrawInstruction,\n} from '../instructions';\n\nexport const STAKE_PROGRAM_ADDRESS =\n  'Stake11111111111111111111111111111111111111' as Address<'Stake11111111111111111111111111111111111111'>;\n\nexport enum StakeAccount {\n  StakeStateAccount,\n}\n\nexport enum StakeInstruction {\n  Initialize,\n  Authorize,\n  DelegateStake,\n  Split,\n  Withdraw,\n  Deactivate,\n  SetLockup,\n  Merge,\n  AuthorizeWithSeed,\n  InitializeChecked,\n  AuthorizeChecked,\n  AuthorizeCheckedWithSeed,\n  SetLockupChecked,\n  GetMinimumDelegation,\n  DeactivateDelinquent,\n  MoveStake,\n  MoveLamports,\n}\n\nexport function identifyStakeInstruction(\n  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): StakeInstruction {\n  const data = 'data' in instruction ? instruction.data : instruction;\n  if (containsBytes(data, getU32Encoder().encode(0), 0)) {\n    return StakeInstruction.Initialize;\n  }\n  if (containsBytes(data, getU32Encoder().encode(1), 0)) {\n    return StakeInstruction.Authorize;\n  }\n  if (containsBytes(data, getU32Encoder().encode(2), 0)) {\n    return StakeInstruction.DelegateStake;\n  }\n  if (containsBytes(data, getU32Encoder().encode(3), 0)) {\n    return StakeInstruction.Split;\n  }\n  if (containsBytes(data, getU32Encoder().encode(4), 0)) {\n    return StakeInstruction.Withdraw;\n  }\n  if (containsBytes(data, getU32Encoder().encode(5), 0)) {\n    return StakeInstruction.Deactivate;\n  }\n  if (containsBytes(data, getU32Encoder().encode(6), 0)) {\n    return StakeInstruction.SetLockup;\n  }\n  if (containsBytes(data, getU32Encoder().encode(7), 0)) {\n    return StakeInstruction.Merge;\n  }\n  if (containsBytes(data, getU32Encoder().encode(8), 0)) {\n    return StakeInstruction.AuthorizeWithSeed;\n  }\n  if (containsBytes(data, getU32Encoder().encode(9), 0)) {\n    return StakeInstruction.InitializeChecked;\n  }\n  if (containsBytes(data, getU32Encoder().encode(10), 0)) {\n    return StakeInstruction.AuthorizeChecked;\n  }\n  if (containsBytes(data, getU32Encoder().encode(11), 0)) {\n    return StakeInstruction.AuthorizeCheckedWithSeed;\n  }\n  if (containsBytes(data, getU32Encoder().encode(12), 0)) {\n    return StakeInstruction.SetLockupChecked;\n  }\n  if (containsBytes(data, getU32Encoder().encode(13), 0)) {\n    return StakeInstruction.GetMinimumDelegation;\n  }\n  if (containsBytes(data, getU32Encoder().encode(14), 0)) {\n    return StakeInstruction.DeactivateDelinquent;\n  }\n  if (containsBytes(data, getU32Encoder().encode(16), 0)) {\n    return StakeInstruction.MoveStake;\n  }\n  if (containsBytes(data, getU32Encoder().encode(17), 0)) {\n    return StakeInstruction.MoveLamports;\n  }\n  throw new Error(\n    'The provided instruction could not be identified as a stake instruction.'\n  );\n}\n\nexport type ParsedStakeInstruction<\n  TProgram extends string = 'Stake11111111111111111111111111111111111111',\n> =\n  | ({\n      instructionType: StakeInstruction.Initialize;\n    } & ParsedInitializeInstruction<TProgram>)\n  | ({\n      instructionType: StakeInstruction.Authorize;\n    } & ParsedAuthorizeInstruction<TProgram>)\n  | ({\n      instructionType: StakeInstruction.DelegateStake;\n    } & ParsedDelegateStakeInstruction<TProgram>)\n  | ({\n      instructionType: StakeInstruction.Split;\n    } & ParsedSplitInstruction<TProgram>)\n  | ({\n      instructionType: StakeInstruction.Withdraw;\n    } & ParsedWithdrawInstruction<TProgram>)\n  | ({\n      instructionType: StakeInstruction.Deactivate;\n    } & ParsedDeactivateInstruction<TProgram>)\n  | ({\n      instructionType: StakeInstruction.SetLockup;\n    } & ParsedSetLockupInstruction<TProgram>)\n  | ({\n      instructionType: StakeInstruction.Merge;\n    } & ParsedMergeInstruction<TProgram>)\n  | ({\n      instructionType: StakeInstruction.AuthorizeWithSeed;\n    } & ParsedAuthorizeWithSeedInstruction<TProgram>)\n  | ({\n      instructionType: StakeInstruction.InitializeChecked;\n    } & ParsedInitializeCheckedInstruction<TProgram>)\n  | ({\n      instructionType: StakeInstruction.AuthorizeChecked;\n    } & ParsedAuthorizeCheckedInstruction<TProgram>)\n  | ({\n      instructionType: StakeInstruction.AuthorizeCheckedWithSeed;\n    } & ParsedAuthorizeCheckedWithSeedInstruction<TProgram>)\n  | ({\n      instructionType: StakeInstruction.SetLockupChecked;\n    } & ParsedSetLockupCheckedInstruction<TProgram>)\n  | ({\n      instructionType: StakeInstruction.GetMinimumDelegation;\n    } & ParsedGetMinimumDelegationInstruction<TProgram>)\n  | ({\n      instructionType: StakeInstruction.DeactivateDelinquent;\n    } & ParsedDeactivateDelinquentInstruction<TProgram>)\n  | ({\n      instructionType: StakeInstruction.MoveStake;\n    } & ParsedMoveStakeInstruction<TProgram>)\n  | ({\n      instructionType: StakeInstruction.MoveLamports;\n    } & ParsedMoveLamportsInstruction<TProgram>);\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  isProgramError,\n  type Address,\n  type SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n  type SolanaError,\n} from '@solana/kit';\nimport { STAKE_PROGRAM_ADDRESS } from '../programs';\n\nexport const STAKE_ERROR__NO_CREDITS_TO_REDEEM = 0x0; // 0\nexport const STAKE_ERROR__LOCKUP_IN_FORCE = 0x1; // 1\nexport const STAKE_ERROR__ALREADY_DEACTIVATED = 0x2; // 2\nexport const STAKE_ERROR__TOO_SOON_TO_REDELEGATE = 0x3; // 3\nexport const STAKE_ERROR__INSUFFICIENT_STAKE = 0x4; // 4\nexport const STAKE_ERROR__MERGE_TRANSIENT_STAKE = 0x5; // 5\nexport const STAKE_ERROR__MERGE_MISMATCH = 0x6; // 6\nexport const STAKE_ERROR__CUSTODIAN_MISSING = 0x7; // 7\nexport const STAKE_ERROR__CUSTODIAN_SIGNATURE_MISSING = 0x8; // 8\nexport const STAKE_ERROR__INSUFFICIENT_REFERENCE_VOTES = 0x9; // 9\nexport const STAKE_ERROR__VOTE_ADDRESS_MISMATCH = 0xa; // 10\nexport const STAKE_ERROR__MINIMUM_DELINQUENT_EPOCHS_FOR_DEACTIVATION_NOT_MET = 0xb; // 11\nexport const STAKE_ERROR__INSUFFICIENT_DELEGATION = 0xc; // 12\nexport const STAKE_ERROR__REDELEGATE_TRANSIENT_OR_INACTIVE_STAKE = 0xd; // 13\nexport const STAKE_ERROR__REDELEGATE_TO_SAME_VOTE_ACCOUNT = 0xe; // 14\nexport const STAKE_ERROR__REDELEGATED_STAKE_MUST_FULLY_ACTIVATE_BEFORE_DEACTIVATION_IS_PERMITTED = 0xf; // 15\nexport const STAKE_ERROR__EPOCH_REWARDS_ACTIVE = 0x10; // 16\n\nexport type StakeError =\n  | typeof STAKE_ERROR__ALREADY_DEACTIVATED\n  | typeof STAKE_ERROR__CUSTODIAN_MISSING\n  | typeof STAKE_ERROR__CUSTODIAN_SIGNATURE_MISSING\n  | typeof STAKE_ERROR__EPOCH_REWARDS_ACTIVE\n  | typeof STAKE_ERROR__INSUFFICIENT_DELEGATION\n  | typeof STAKE_ERROR__INSUFFICIENT_REFERENCE_VOTES\n  | typeof STAKE_ERROR__INSUFFICIENT_STAKE\n  | typeof STAKE_ERROR__LOCKUP_IN_FORCE\n  | typeof STAKE_ERROR__MERGE_MISMATCH\n  | typeof STAKE_ERROR__MERGE_TRANSIENT_STAKE\n  | typeof STAKE_ERROR__MINIMUM_DELINQUENT_EPOCHS_FOR_DEACTIVATION_NOT_MET\n  | typeof STAKE_ERROR__NO_CREDITS_TO_REDEEM\n  | typeof STAKE_ERROR__REDELEGATED_STAKE_MUST_FULLY_ACTIVATE_BEFORE_DEACTIVATION_IS_PERMITTED\n  | typeof STAKE_ERROR__REDELEGATE_TO_SAME_VOTE_ACCOUNT\n  | typeof STAKE_ERROR__REDELEGATE_TRANSIENT_OR_INACTIVE_STAKE\n  | typeof STAKE_ERROR__TOO_SOON_TO_REDELEGATE\n  | typeof STAKE_ERROR__VOTE_ADDRESS_MISMATCH;\n\nlet stakeErrorMessages: Record<StakeError, string> | undefined;\nif (process.env.NODE_ENV !== 'production') {\n  stakeErrorMessages = {\n    [STAKE_ERROR__ALREADY_DEACTIVATED]: `Stake already deactivated`,\n    [STAKE_ERROR__CUSTODIAN_MISSING]: `Custodian address not present`,\n    [STAKE_ERROR__CUSTODIAN_SIGNATURE_MISSING]: `Custodian signature not present`,\n    [STAKE_ERROR__EPOCH_REWARDS_ACTIVE]: `Stake action is not permitted while the epoch rewards period is active`,\n    [STAKE_ERROR__INSUFFICIENT_DELEGATION]: `Delegation amount is less than the minimum`,\n    [STAKE_ERROR__INSUFFICIENT_REFERENCE_VOTES]: `Insufficient voting activity in the reference vote account`,\n    [STAKE_ERROR__INSUFFICIENT_STAKE]: `Split amount is more than is staked`,\n    [STAKE_ERROR__LOCKUP_IN_FORCE]: `Lockup has not yet expired`,\n    [STAKE_ERROR__MERGE_MISMATCH]: `Stake account merge failed due to different authority, lockups or state`,\n    [STAKE_ERROR__MERGE_TRANSIENT_STAKE]: `Stake account with transient stake cannot be merged`,\n    [STAKE_ERROR__MINIMUM_DELINQUENT_EPOCHS_FOR_DEACTIVATION_NOT_MET]: `Stake account has not been delinquent for the minimum epochs required for deactivation`,\n    [STAKE_ERROR__NO_CREDITS_TO_REDEEM]: `Not enough credits to redeem`,\n    [STAKE_ERROR__REDELEGATED_STAKE_MUST_FULLY_ACTIVATE_BEFORE_DEACTIVATION_IS_PERMITTED]: `Redelegated stake must be fully activated before deactivation`,\n    [STAKE_ERROR__REDELEGATE_TO_SAME_VOTE_ACCOUNT]: `Stake redelegation to the same vote account is not permitted`,\n    [STAKE_ERROR__REDELEGATE_TRANSIENT_OR_INACTIVE_STAKE]: `Stake account with transient or inactive stake cannot be redelegated`,\n    [STAKE_ERROR__TOO_SOON_TO_REDELEGATE]: `One re-delegation permitted per epoch`,\n    [STAKE_ERROR__VOTE_ADDRESS_MISMATCH]: `Stake account is not delegated to the provided vote account`,\n  };\n}\n\nexport function getStakeErrorMessage(code: StakeError): string {\n  if (process.env.NODE_ENV !== 'production') {\n    return (stakeErrorMessages as Record<StakeError, string>)[code];\n  }\n\n  return 'Error message not available in production bundles.';\n}\n\nexport function isStakeError<TProgramErrorCode extends StakeError>(\n  error: unknown,\n  transactionMessage: {\n    instructions: Record<number, { programAddress: Address }>;\n  },\n  code?: TProgramErrorCode\n): error is SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> &\n  Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> {\n  return isProgramError<TProgramErrorCode>(\n    error,\n    transactionMessage,\n    STAKE_PROGRAM_ADDRESS,\n    code\n  );\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  isProgramDerivedAddress,\n  isTransactionSigner as kitIsTransactionSigner,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type ProgramDerivedAddress,\n  type TransactionSigner,\n  upgradeRoleToSigner,\n} from '@solana/kit';\n\n/**\n * Asserts that the given value is not null or undefined.\n * @internal\n */\nexport function expectSome<T>(value: T | null | undefined): T {\n  if (value === null || value === undefined) {\n    throw new Error('Expected a value but received null or undefined.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a PublicKey.\n * @internal\n */\nexport function expectAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): Address<T> {\n  if (!value) {\n    throw new Error('Expected a Address.');\n  }\n  if (typeof value === 'object' && 'address' in value) {\n    return value.address;\n  }\n  if (Array.isArray(value)) {\n    return value[0] as Address<T>;\n  }\n  return value as Address<T>;\n}\n\n/**\n * Asserts that the given value is a PDA.\n * @internal\n */\nexport function expectProgramDerivedAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): ProgramDerivedAddress<T> {\n  if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {\n    throw new Error('Expected a ProgramDerivedAddress.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a TransactionSigner.\n * @internal\n */\nexport function expectTransactionSigner<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): TransactionSigner<T> {\n  if (!value || !isTransactionSigner(value)) {\n    throw new Error('Expected a TransactionSigner.');\n  }\n  return value;\n}\n\n/**\n * Defines an instruction account to resolve.\n * @internal\n */\nexport type ResolvedAccount<\n  T extends string = string,\n  U extends\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null =\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null,\n> = {\n  isWritable: boolean;\n  value: U;\n};\n\n/**\n * Defines an instruction that stores additional bytes on-chain.\n * @internal\n */\nexport type InstructionWithByteDelta = {\n  byteDelta: number;\n};\n\n/**\n * Get account metas and signers from resolved accounts.\n * @internal\n */\nexport function getAccountMetaFactory(\n  programAddress: Address,\n  optionalAccountStrategy: 'omitted' | 'programId'\n) {\n  return (\n    account: ResolvedAccount\n  ): AccountMeta | AccountSignerMeta | undefined => {\n    if (!account.value) {\n      if (optionalAccountStrategy === 'omitted') return;\n      return Object.freeze({\n        address: programAddress,\n        role: AccountRole.READONLY,\n      });\n    }\n\n    const writableRole = account.isWritable\n      ? AccountRole.WRITABLE\n      : AccountRole.READONLY;\n    return Object.freeze({\n      address: expectAddress(account.value),\n      role: isTransactionSigner(account.value)\n        ? upgradeRoleToSigner(writableRole)\n        : writableRole,\n      ...(isTransactionSigner(account.value) ? { signer: account.value } : {}),\n    });\n  };\n}\n\nexport function isTransactionSigner<TAddress extends string = string>(\n  value:\n    | Address<TAddress>\n    | ProgramDerivedAddress<TAddress>\n    | TransactionSigner<TAddress>\n): value is TransactionSigner<TAddress> {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    'address' in value &&\n    kitIsTransactionSigner(value)\n  );\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { STAKE_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getStakeAuthorizeDecoder,\n  getStakeAuthorizeEncoder,\n  type StakeAuthorize,\n  type StakeAuthorizeArgs,\n} from '../types';\n\nexport const AUTHORIZE_DISCRIMINATOR = 1;\n\nexport function getAuthorizeDiscriminatorBytes() {\n  return getU32Encoder().encode(AUTHORIZE_DISCRIMINATOR);\n}\n\nexport type AuthorizeInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountStake extends string | AccountMeta<string> = string,\n  TAccountClockSysvar extends\n    | string\n    | AccountMeta<string> = 'SysvarC1ock11111111111111111111111111111111',\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TAccountLockupAuthority extends\n    | string\n    | AccountMeta<string>\n    | undefined = undefined,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountStake extends string\n        ? WritableAccount<TAccountStake>\n        : TAccountStake,\n      TAccountClockSysvar extends string\n        ? ReadonlyAccount<TAccountClockSysvar>\n        : TAccountClockSysvar,\n      TAccountAuthority extends string\n        ? ReadonlySignerAccount<TAccountAuthority> &\n            AccountSignerMeta<TAccountAuthority>\n        : TAccountAuthority,\n      ...(TAccountLockupAuthority extends undefined\n        ? []\n        : [\n            TAccountLockupAuthority extends string\n              ? ReadonlySignerAccount<TAccountLockupAuthority> &\n                  AccountSignerMeta<TAccountLockupAuthority>\n              : TAccountLockupAuthority,\n          ]),\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AuthorizeInstructionData = {\n  discriminator: number;\n  arg0: Address;\n  arg1: StakeAuthorize;\n};\n\nexport type AuthorizeInstructionDataArgs = {\n  arg0: Address;\n  arg1: StakeAuthorizeArgs;\n};\n\nexport function getAuthorizeInstructionDataEncoder(): FixedSizeEncoder<AuthorizeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['arg0', getAddressEncoder()],\n      ['arg1', getStakeAuthorizeEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: AUTHORIZE_DISCRIMINATOR })\n  );\n}\n\nexport function getAuthorizeInstructionDataDecoder(): FixedSizeDecoder<AuthorizeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['arg0', getAddressDecoder()],\n    ['arg1', getStakeAuthorizeDecoder()],\n  ]);\n}\n\nexport function getAuthorizeInstructionDataCodec(): FixedSizeCodec<\n  AuthorizeInstructionDataArgs,\n  AuthorizeInstructionData\n> {\n  return combineCodec(\n    getAuthorizeInstructionDataEncoder(),\n    getAuthorizeInstructionDataDecoder()\n  );\n}\n\nexport type AuthorizeInput<\n  TAccountStake extends string = string,\n  TAccountClockSysvar extends string = string,\n  TAccountAuthority extends string = string,\n  TAccountLockupAuthority extends string = string,\n> = {\n  /** Stake account to be updated */\n  stake: Address<TAccountStake>;\n  /** Clock sysvar */\n  clockSysvar?: Address<TAccountClockSysvar>;\n  /** Stake or withdraw authority */\n  authority: TransactionSigner<TAccountAuthority>;\n  /** Lockup authority */\n  lockupAuthority?: TransactionSigner<TAccountLockupAuthority>;\n  arg0: AuthorizeInstructionDataArgs['arg0'];\n  arg1: AuthorizeInstructionDataArgs['arg1'];\n};\n\nexport function getAuthorizeInstruction<\n  TAccountStake extends string,\n  TAccountClockSysvar extends string,\n  TAccountAuthority extends string,\n  TAccountLockupAuthority extends string,\n  TProgramAddress extends Address = typeof STAKE_PROGRAM_ADDRESS,\n>(\n  input: AuthorizeInput<\n    TAccountStake,\n    TAccountClockSysvar,\n    TAccountAuthority,\n    TAccountLockupAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): AuthorizeInstruction<\n  TProgramAddress,\n  TAccountStake,\n  TAccountClockSysvar,\n  TAccountAuthority,\n  TAccountLockupAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? STAKE_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    stake: { value: input.stake ?? null, isWritable: true },\n    clockSysvar: { value: input.clockSysvar ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n    lockupAuthority: {\n      value: input.lockupAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.clockSysvar.value) {\n    accounts.clockSysvar.value =\n      'SysvarC1ock11111111111111111111111111111111' as Address<'SysvarC1ock11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.stake),\n      getAccountMeta(accounts.clockSysvar),\n      getAccountMeta(accounts.authority),\n      getAccountMeta(accounts.lockupAuthority),\n    ].filter(<T>(x: T | undefined): x is T => x !== undefined),\n    data: getAuthorizeInstructionDataEncoder().encode(\n      args as AuthorizeInstructionDataArgs\n    ),\n    programAddress,\n  } as AuthorizeInstruction<\n    TProgramAddress,\n    TAccountStake,\n    TAccountClockSysvar,\n    TAccountAuthority,\n    TAccountLockupAuthority\n  >);\n}\n\nexport type ParsedAuthorizeInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Stake account to be updated */\n    stake: TAccountMetas[0];\n    /** Clock sysvar */\n    clockSysvar: TAccountMetas[1];\n    /** Stake or withdraw authority */\n    authority: TAccountMetas[2];\n    /** Lockup authority */\n    lockupAuthority?: TAccountMetas[3] | undefined;\n  };\n  data: AuthorizeInstructionData;\n};\n\nexport function parseAuthorizeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedAuthorizeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  let optionalAccountsRemaining = instruction.accounts.length - 3;\n  const getNextOptionalAccount = () => {\n    if (optionalAccountsRemaining === 0) return undefined;\n    optionalAccountsRemaining -= 1;\n    return getNextAccount();\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      stake: getNextAccount(),\n      clockSysvar: getNextAccount(),\n      authority: getNextAccount(),\n      lockupAuthority: getNextOptionalAccount(),\n    },\n    data: getAuthorizeInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { STAKE_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getStakeAuthorizeDecoder,\n  getStakeAuthorizeEncoder,\n  type StakeAuthorize,\n  type StakeAuthorizeArgs,\n} from '../types';\n\nexport const AUTHORIZE_CHECKED_DISCRIMINATOR = 10;\n\nexport function getAuthorizeCheckedDiscriminatorBytes() {\n  return getU32Encoder().encode(AUTHORIZE_CHECKED_DISCRIMINATOR);\n}\n\nexport type AuthorizeCheckedInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountStake extends string | AccountMeta<string> = string,\n  TAccountClockSysvar extends\n    | string\n    | AccountMeta<string> = 'SysvarC1ock11111111111111111111111111111111',\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TAccountNewAuthority extends string | AccountMeta<string> = string,\n  TAccountLockupAuthority extends\n    | string\n    | AccountMeta<string>\n    | undefined = undefined,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountStake extends string\n        ? WritableAccount<TAccountStake>\n        : TAccountStake,\n      TAccountClockSysvar extends string\n        ? ReadonlyAccount<TAccountClockSysvar>\n        : TAccountClockSysvar,\n      TAccountAuthority extends string\n        ? ReadonlySignerAccount<TAccountAuthority> &\n            AccountSignerMeta<TAccountAuthority>\n        : TAccountAuthority,\n      TAccountNewAuthority extends string\n        ? ReadonlySignerAccount<TAccountNewAuthority> &\n            AccountSignerMeta<TAccountNewAuthority>\n        : TAccountNewAuthority,\n      ...(TAccountLockupAuthority extends undefined\n        ? []\n        : [\n            TAccountLockupAuthority extends string\n              ? ReadonlySignerAccount<TAccountLockupAuthority> &\n                  AccountSignerMeta<TAccountLockupAuthority>\n              : TAccountLockupAuthority,\n          ]),\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AuthorizeCheckedInstructionData = {\n  discriminator: number;\n  stakeAuthorize: StakeAuthorize;\n};\n\nexport type AuthorizeCheckedInstructionDataArgs = {\n  stakeAuthorize: StakeAuthorizeArgs;\n};\n\nexport function getAuthorizeCheckedInstructionDataEncoder(): FixedSizeEncoder<AuthorizeCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['stakeAuthorize', getStakeAuthorizeEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: AUTHORIZE_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getAuthorizeCheckedInstructionDataDecoder(): FixedSizeDecoder<AuthorizeCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['stakeAuthorize', getStakeAuthorizeDecoder()],\n  ]);\n}\n\nexport function getAuthorizeCheckedInstructionDataCodec(): FixedSizeCodec<\n  AuthorizeCheckedInstructionDataArgs,\n  AuthorizeCheckedInstructionData\n> {\n  return combineCodec(\n    getAuthorizeCheckedInstructionDataEncoder(),\n    getAuthorizeCheckedInstructionDataDecoder()\n  );\n}\n\nexport type AuthorizeCheckedInput<\n  TAccountStake extends string = string,\n  TAccountClockSysvar extends string = string,\n  TAccountAuthority extends string = string,\n  TAccountNewAuthority extends string = string,\n  TAccountLockupAuthority extends string = string,\n> = {\n  /** Stake account to be updated */\n  stake: Address<TAccountStake>;\n  /** Clock sysvar */\n  clockSysvar?: Address<TAccountClockSysvar>;\n  /** The stake or withdraw authority */\n  authority: TransactionSigner<TAccountAuthority>;\n  /** The new stake or withdraw authority */\n  newAuthority: TransactionSigner<TAccountNewAuthority>;\n  /** Lockup authority */\n  lockupAuthority?: TransactionSigner<TAccountLockupAuthority>;\n  stakeAuthorize: AuthorizeCheckedInstructionDataArgs['stakeAuthorize'];\n};\n\nexport function getAuthorizeCheckedInstruction<\n  TAccountStake extends string,\n  TAccountClockSysvar extends string,\n  TAccountAuthority extends string,\n  TAccountNewAuthority extends string,\n  TAccountLockupAuthority extends string,\n  TProgramAddress extends Address = typeof STAKE_PROGRAM_ADDRESS,\n>(\n  input: AuthorizeCheckedInput<\n    TAccountStake,\n    TAccountClockSysvar,\n    TAccountAuthority,\n    TAccountNewAuthority,\n    TAccountLockupAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): AuthorizeCheckedInstruction<\n  TProgramAddress,\n  TAccountStake,\n  TAccountClockSysvar,\n  TAccountAuthority,\n  TAccountNewAuthority,\n  TAccountLockupAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? STAKE_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    stake: { value: input.stake ?? null, isWritable: true },\n    clockSysvar: { value: input.clockSysvar ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n    newAuthority: { value: input.newAuthority ?? null, isWritable: false },\n    lockupAuthority: {\n      value: input.lockupAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.clockSysvar.value) {\n    accounts.clockSysvar.value =\n      'SysvarC1ock11111111111111111111111111111111' as Address<'SysvarC1ock11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.stake),\n      getAccountMeta(accounts.clockSysvar),\n      getAccountMeta(accounts.authority),\n      getAccountMeta(accounts.newAuthority),\n      getAccountMeta(accounts.lockupAuthority),\n    ].filter(<T>(x: T | undefined): x is T => x !== undefined),\n    data: getAuthorizeCheckedInstructionDataEncoder().encode(\n      args as AuthorizeCheckedInstructionDataArgs\n    ),\n    programAddress,\n  } as AuthorizeCheckedInstruction<\n    TProgramAddress,\n    TAccountStake,\n    TAccountClockSysvar,\n    TAccountAuthority,\n    TAccountNewAuthority,\n    TAccountLockupAuthority\n  >);\n}\n\nexport type ParsedAuthorizeCheckedInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Stake account to be updated */\n    stake: TAccountMetas[0];\n    /** Clock sysvar */\n    clockSysvar: TAccountMetas[1];\n    /** The stake or withdraw authority */\n    authority: TAccountMetas[2];\n    /** The new stake or withdraw authority */\n    newAuthority: TAccountMetas[3];\n    /** Lockup authority */\n    lockupAuthority?: TAccountMetas[4] | undefined;\n  };\n  data: AuthorizeCheckedInstructionData;\n};\n\nexport function parseAuthorizeCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedAuthorizeCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  let optionalAccountsRemaining = instruction.accounts.length - 4;\n  const getNextOptionalAccount = () => {\n    if (optionalAccountsRemaining === 0) return undefined;\n    optionalAccountsRemaining -= 1;\n    return getNextAccount();\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      stake: getNextAccount(),\n      clockSysvar: getNextAccount(),\n      authority: getNextAccount(),\n      newAuthority: getNextAccount(),\n      lockupAuthority: getNextOptionalAccount(),\n    },\n    data: getAuthorizeCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { STAKE_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getStakeAuthorizeDecoder,\n  getStakeAuthorizeEncoder,\n  type StakeAuthorize,\n  type StakeAuthorizeArgs,\n} from '../types';\n\nexport const AUTHORIZE_CHECKED_WITH_SEED_DISCRIMINATOR = 11;\n\nexport function getAuthorizeCheckedWithSeedDiscriminatorBytes() {\n  return getU32Encoder().encode(AUTHORIZE_CHECKED_WITH_SEED_DISCRIMINATOR);\n}\n\nexport type AuthorizeCheckedWithSeedInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountStake extends string | AccountMeta<string> = string,\n  TAccountBase extends string | AccountMeta<string> = string,\n  TAccountClockSysvar extends\n    | string\n    | AccountMeta<string> = 'SysvarC1ock11111111111111111111111111111111',\n  TAccountNewAuthority extends string | AccountMeta<string> = string,\n  TAccountLockupAuthority extends\n    | string\n    | AccountMeta<string>\n    | undefined = undefined,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountStake extends string\n        ? WritableAccount<TAccountStake>\n        : TAccountStake,\n      TAccountBase extends string\n        ? ReadonlySignerAccount<TAccountBase> & AccountSignerMeta<TAccountBase>\n        : TAccountBase,\n      TAccountClockSysvar extends string\n        ? ReadonlyAccount<TAccountClockSysvar>\n        : TAccountClockSysvar,\n      TAccountNewAuthority extends string\n        ? ReadonlySignerAccount<TAccountNewAuthority> &\n            AccountSignerMeta<TAccountNewAuthority>\n        : TAccountNewAuthority,\n      ...(TAccountLockupAuthority extends undefined\n        ? []\n        : [\n            TAccountLockupAuthority extends string\n              ? ReadonlySignerAccount<TAccountLockupAuthority> &\n                  AccountSignerMeta<TAccountLockupAuthority>\n              : TAccountLockupAuthority,\n          ]),\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AuthorizeCheckedWithSeedInstructionData = {\n  discriminator: number;\n  stakeAuthorize: StakeAuthorize;\n  authoritySeed: string;\n  authorityOwner: Address;\n};\n\nexport type AuthorizeCheckedWithSeedInstructionDataArgs = {\n  stakeAuthorize: StakeAuthorizeArgs;\n  authoritySeed: string;\n  authorityOwner: Address;\n};\n\nexport function getAuthorizeCheckedWithSeedInstructionDataEncoder(): Encoder<AuthorizeCheckedWithSeedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['stakeAuthorize', getStakeAuthorizeEncoder()],\n      [\n        'authoritySeed',\n        addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()),\n      ],\n      ['authorityOwner', getAddressEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: AUTHORIZE_CHECKED_WITH_SEED_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getAuthorizeCheckedWithSeedInstructionDataDecoder(): Decoder<AuthorizeCheckedWithSeedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['stakeAuthorize', getStakeAuthorizeDecoder()],\n    ['authoritySeed', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    ['authorityOwner', getAddressDecoder()],\n  ]);\n}\n\nexport function getAuthorizeCheckedWithSeedInstructionDataCodec(): Codec<\n  AuthorizeCheckedWithSeedInstructionDataArgs,\n  AuthorizeCheckedWithSeedInstructionData\n> {\n  return combineCodec(\n    getAuthorizeCheckedWithSeedInstructionDataEncoder(),\n    getAuthorizeCheckedWithSeedInstructionDataDecoder()\n  );\n}\n\nexport type AuthorizeCheckedWithSeedInput<\n  TAccountStake extends string = string,\n  TAccountBase extends string = string,\n  TAccountClockSysvar extends string = string,\n  TAccountNewAuthority extends string = string,\n  TAccountLockupAuthority extends string = string,\n> = {\n  /** Stake account to be updated */\n  stake: Address<TAccountStake>;\n  /** Base key of stake or withdraw authority */\n  base: TransactionSigner<TAccountBase>;\n  /** Clock sysvar */\n  clockSysvar?: Address<TAccountClockSysvar>;\n  /** The new stake or withdraw authority */\n  newAuthority: TransactionSigner<TAccountNewAuthority>;\n  /** Lockup authority */\n  lockupAuthority?: TransactionSigner<TAccountLockupAuthority>;\n  stakeAuthorize: AuthorizeCheckedWithSeedInstructionDataArgs['stakeAuthorize'];\n  authoritySeed: AuthorizeCheckedWithSeedInstructionDataArgs['authoritySeed'];\n  authorityOwner: AuthorizeCheckedWithSeedInstructionDataArgs['authorityOwner'];\n};\n\nexport function getAuthorizeCheckedWithSeedInstruction<\n  TAccountStake extends string,\n  TAccountBase extends string,\n  TAccountClockSysvar extends string,\n  TAccountNewAuthority extends string,\n  TAccountLockupAuthority extends string,\n  TProgramAddress extends Address = typeof STAKE_PROGRAM_ADDRESS,\n>(\n  input: AuthorizeCheckedWithSeedInput<\n    TAccountStake,\n    TAccountBase,\n    TAccountClockSysvar,\n    TAccountNewAuthority,\n    TAccountLockupAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): AuthorizeCheckedWithSeedInstruction<\n  TProgramAddress,\n  TAccountStake,\n  TAccountBase,\n  TAccountClockSysvar,\n  TAccountNewAuthority,\n  TAccountLockupAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? STAKE_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    stake: { value: input.stake ?? null, isWritable: true },\n    base: { value: input.base ?? null, isWritable: false },\n    clockSysvar: { value: input.clockSysvar ?? null, isWritable: false },\n    newAuthority: { value: input.newAuthority ?? null, isWritable: false },\n    lockupAuthority: {\n      value: input.lockupAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.clockSysvar.value) {\n    accounts.clockSysvar.value =\n      'SysvarC1ock11111111111111111111111111111111' as Address<'SysvarC1ock11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.stake),\n      getAccountMeta(accounts.base),\n      getAccountMeta(accounts.clockSysvar),\n      getAccountMeta(accounts.newAuthority),\n      getAccountMeta(accounts.lockupAuthority),\n    ].filter(<T>(x: T | undefined): x is T => x !== undefined),\n    data: getAuthorizeCheckedWithSeedInstructionDataEncoder().encode(\n      args as AuthorizeCheckedWithSeedInstructionDataArgs\n    ),\n    programAddress,\n  } as AuthorizeCheckedWithSeedInstruction<\n    TProgramAddress,\n    TAccountStake,\n    TAccountBase,\n    TAccountClockSysvar,\n    TAccountNewAuthority,\n    TAccountLockupAuthority\n  >);\n}\n\nexport type ParsedAuthorizeCheckedWithSeedInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Stake account to be updated */\n    stake: TAccountMetas[0];\n    /** Base key of stake or withdraw authority */\n    base: TAccountMetas[1];\n    /** Clock sysvar */\n    clockSysvar: TAccountMetas[2];\n    /** The new stake or withdraw authority */\n    newAuthority: TAccountMetas[3];\n    /** Lockup authority */\n    lockupAuthority?: TAccountMetas[4] | undefined;\n  };\n  data: AuthorizeCheckedWithSeedInstructionData;\n};\n\nexport function parseAuthorizeCheckedWithSeedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedAuthorizeCheckedWithSeedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  let optionalAccountsRemaining = instruction.accounts.length - 4;\n  const getNextOptionalAccount = () => {\n    if (optionalAccountsRemaining === 0) return undefined;\n    optionalAccountsRemaining -= 1;\n    return getNextAccount();\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      stake: getNextAccount(),\n      base: getNextAccount(),\n      clockSysvar: getNextAccount(),\n      newAuthority: getNextAccount(),\n      lockupAuthority: getNextOptionalAccount(),\n    },\n    data: getAuthorizeCheckedWithSeedInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { STAKE_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getStakeAuthorizeDecoder,\n  getStakeAuthorizeEncoder,\n  type StakeAuthorize,\n  type StakeAuthorizeArgs,\n} from '../types';\n\nexport const AUTHORIZE_WITH_SEED_DISCRIMINATOR = 8;\n\nexport function getAuthorizeWithSeedDiscriminatorBytes() {\n  return getU32Encoder().encode(AUTHORIZE_WITH_SEED_DISCRIMINATOR);\n}\n\nexport type AuthorizeWithSeedInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountStake extends string | AccountMeta<string> = string,\n  TAccountBase extends string | AccountMeta<string> = string,\n  TAccountClockSysvar extends\n    | string\n    | AccountMeta<string> = 'SysvarC1ock11111111111111111111111111111111',\n  TAccountLockupAuthority extends\n    | string\n    | AccountMeta<string>\n    | undefined = undefined,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountStake extends string\n        ? WritableAccount<TAccountStake>\n        : TAccountStake,\n      TAccountBase extends string\n        ? ReadonlySignerAccount<TAccountBase> & AccountSignerMeta<TAccountBase>\n        : TAccountBase,\n      TAccountClockSysvar extends string\n        ? ReadonlyAccount<TAccountClockSysvar>\n        : TAccountClockSysvar,\n      ...(TAccountLockupAuthority extends undefined\n        ? []\n        : [\n            TAccountLockupAuthority extends string\n              ? ReadonlySignerAccount<TAccountLockupAuthority> &\n                  AccountSignerMeta<TAccountLockupAuthority>\n              : TAccountLockupAuthority,\n          ]),\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AuthorizeWithSeedInstructionData = {\n  discriminator: number;\n  newAuthorizedPubkey: Address;\n  stakeAuthorize: StakeAuthorize;\n  authoritySeed: string;\n  authorityOwner: Address;\n};\n\nexport type AuthorizeWithSeedInstructionDataArgs = {\n  newAuthorizedPubkey: Address;\n  stakeAuthorize: StakeAuthorizeArgs;\n  authoritySeed: string;\n  authorityOwner: Address;\n};\n\nexport function getAuthorizeWithSeedInstructionDataEncoder(): Encoder<AuthorizeWithSeedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['newAuthorizedPubkey', getAddressEncoder()],\n      ['stakeAuthorize', getStakeAuthorizeEncoder()],\n      [\n        'authoritySeed',\n        addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()),\n      ],\n      ['authorityOwner', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: AUTHORIZE_WITH_SEED_DISCRIMINATOR })\n  );\n}\n\nexport function getAuthorizeWithSeedInstructionDataDecoder(): Decoder<AuthorizeWithSeedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['newAuthorizedPubkey', getAddressDecoder()],\n    ['stakeAuthorize', getStakeAuthorizeDecoder()],\n    ['authoritySeed', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    ['authorityOwner', getAddressDecoder()],\n  ]);\n}\n\nexport function getAuthorizeWithSeedInstructionDataCodec(): Codec<\n  AuthorizeWithSeedInstructionDataArgs,\n  AuthorizeWithSeedInstructionData\n> {\n  return combineCodec(\n    getAuthorizeWithSeedInstructionDataEncoder(),\n    getAuthorizeWithSeedInstructionDataDecoder()\n  );\n}\n\nexport type AuthorizeWithSeedInput<\n  TAccountStake extends string = string,\n  TAccountBase extends string = string,\n  TAccountClockSysvar extends string = string,\n  TAccountLockupAuthority extends string = string,\n> = {\n  /** Stake account to be updated */\n  stake: Address<TAccountStake>;\n  /** Base key of stake or withdraw authority */\n  base: TransactionSigner<TAccountBase>;\n  /** Clock sysvar */\n  clockSysvar?: Address<TAccountClockSysvar>;\n  /** Lockup authority */\n  lockupAuthority?: TransactionSigner<TAccountLockupAuthority>;\n  newAuthorizedPubkey: AuthorizeWithSeedInstructionDataArgs['newAuthorizedPubkey'];\n  stakeAuthorize: AuthorizeWithSeedInstructionDataArgs['stakeAuthorize'];\n  authoritySeed: AuthorizeWithSeedInstructionDataArgs['authoritySeed'];\n  authorityOwner: AuthorizeWithSeedInstructionDataArgs['authorityOwner'];\n};\n\nexport function getAuthorizeWithSeedInstruction<\n  TAccountStake extends string,\n  TAccountBase extends string,\n  TAccountClockSysvar extends string,\n  TAccountLockupAuthority extends string,\n  TProgramAddress extends Address = typeof STAKE_PROGRAM_ADDRESS,\n>(\n  input: AuthorizeWithSeedInput<\n    TAccountStake,\n    TAccountBase,\n    TAccountClockSysvar,\n    TAccountLockupAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): AuthorizeWithSeedInstruction<\n  TProgramAddress,\n  TAccountStake,\n  TAccountBase,\n  TAccountClockSysvar,\n  TAccountLockupAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? STAKE_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    stake: { value: input.stake ?? null, isWritable: true },\n    base: { value: input.base ?? null, isWritable: false },\n    clockSysvar: { value: input.clockSysvar ?? null, isWritable: false },\n    lockupAuthority: {\n      value: input.lockupAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.clockSysvar.value) {\n    accounts.clockSysvar.value =\n      'SysvarC1ock11111111111111111111111111111111' as Address<'SysvarC1ock11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.stake),\n      getAccountMeta(accounts.base),\n      getAccountMeta(accounts.clockSysvar),\n      getAccountMeta(accounts.lockupAuthority),\n    ].filter(<T>(x: T | undefined): x is T => x !== undefined),\n    data: getAuthorizeWithSeedInstructionDataEncoder().encode(\n      args as AuthorizeWithSeedInstructionDataArgs\n    ),\n    programAddress,\n  } as AuthorizeWithSeedInstruction<\n    TProgramAddress,\n    TAccountStake,\n    TAccountBase,\n    TAccountClockSysvar,\n    TAccountLockupAuthority\n  >);\n}\n\nexport type ParsedAuthorizeWithSeedInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Stake account to be updated */\n    stake: TAccountMetas[0];\n    /** Base key of stake or withdraw authority */\n    base: TAccountMetas[1];\n    /** Clock sysvar */\n    clockSysvar: TAccountMetas[2];\n    /** Lockup authority */\n    lockupAuthority?: TAccountMetas[3] | undefined;\n  };\n  data: AuthorizeWithSeedInstructionData;\n};\n\nexport function parseAuthorizeWithSeedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedAuthorizeWithSeedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  let optionalAccountsRemaining = instruction.accounts.length - 3;\n  const getNextOptionalAccount = () => {\n    if (optionalAccountsRemaining === 0) return undefined;\n    optionalAccountsRemaining -= 1;\n    return getNextAccount();\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      stake: getNextAccount(),\n      base: getNextAccount(),\n      clockSysvar: getNextAccount(),\n      lockupAuthority: getNextOptionalAccount(),\n    },\n    data: getAuthorizeWithSeedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { STAKE_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const DEACTIVATE_DISCRIMINATOR = 5;\n\nexport function getDeactivateDiscriminatorBytes() {\n  return getU32Encoder().encode(DEACTIVATE_DISCRIMINATOR);\n}\n\nexport type DeactivateInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountStake extends string | AccountMeta<string> = string,\n  TAccountClockSysvar extends\n    | string\n    | AccountMeta<string> = 'SysvarC1ock11111111111111111111111111111111',\n  TAccountStakeAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountStake extends string\n        ? WritableAccount<TAccountStake>\n        : TAccountStake,\n      TAccountClockSysvar extends string\n        ? ReadonlyAccount<TAccountClockSysvar>\n        : TAccountClockSysvar,\n      TAccountStakeAuthority extends string\n        ? ReadonlySignerAccount<TAccountStakeAuthority> &\n            AccountSignerMeta<TAccountStakeAuthority>\n        : TAccountStakeAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type DeactivateInstructionData = { discriminator: number };\n\nexport type DeactivateInstructionDataArgs = {};\n\nexport function getDeactivateInstructionDataEncoder(): FixedSizeEncoder<DeactivateInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU32Encoder()]]),\n    (value) => ({ ...value, discriminator: DEACTIVATE_DISCRIMINATOR })\n  );\n}\n\nexport function getDeactivateInstructionDataDecoder(): FixedSizeDecoder<DeactivateInstructionData> {\n  return getStructDecoder([['discriminator', getU32Decoder()]]);\n}\n\nexport function getDeactivateInstructionDataCodec(): FixedSizeCodec<\n  DeactivateInstructionDataArgs,\n  DeactivateInstructionData\n> {\n  return combineCodec(\n    getDeactivateInstructionDataEncoder(),\n    getDeactivateInstructionDataDecoder()\n  );\n}\n\nexport type DeactivateInput<\n  TAccountStake extends string = string,\n  TAccountClockSysvar extends string = string,\n  TAccountStakeAuthority extends string = string,\n> = {\n  /** Delegated stake account */\n  stake: Address<TAccountStake>;\n  /** Clock sysvar */\n  clockSysvar?: Address<TAccountClockSysvar>;\n  /** Stake authority */\n  stakeAuthority: TransactionSigner<TAccountStakeAuthority>;\n};\n\nexport function getDeactivateInstruction<\n  TAccountStake extends string,\n  TAccountClockSysvar extends string,\n  TAccountStakeAuthority extends string,\n  TProgramAddress extends Address = typeof STAKE_PROGRAM_ADDRESS,\n>(\n  input: DeactivateInput<\n    TAccountStake,\n    TAccountClockSysvar,\n    TAccountStakeAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): DeactivateInstruction<\n  TProgramAddress,\n  TAccountStake,\n  TAccountClockSysvar,\n  TAccountStakeAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? STAKE_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    stake: { value: input.stake ?? null, isWritable: true },\n    clockSysvar: { value: input.clockSysvar ?? null, isWritable: false },\n    stakeAuthority: { value: input.stakeAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.clockSysvar.value) {\n    accounts.clockSysvar.value =\n      'SysvarC1ock11111111111111111111111111111111' as Address<'SysvarC1ock11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.stake),\n      getAccountMeta(accounts.clockSysvar),\n      getAccountMeta(accounts.stakeAuthority),\n    ],\n    data: getDeactivateInstructionDataEncoder().encode({}),\n    programAddress,\n  } as DeactivateInstruction<\n    TProgramAddress,\n    TAccountStake,\n    TAccountClockSysvar,\n    TAccountStakeAuthority\n  >);\n}\n\nexport type ParsedDeactivateInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Delegated stake account */\n    stake: TAccountMetas[0];\n    /** Clock sysvar */\n    clockSysvar: TAccountMetas[1];\n    /** Stake authority */\n    stakeAuthority: TAccountMetas[2];\n  };\n  data: DeactivateInstructionData;\n};\n\nexport function parseDeactivateInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedDeactivateInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      stake: getNextAccount(),\n      clockSysvar: getNextAccount(),\n      stakeAuthority: getNextAccount(),\n    },\n    data: getDeactivateInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { STAKE_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const DEACTIVATE_DELINQUENT_DISCRIMINATOR = 14;\n\nexport function getDeactivateDelinquentDiscriminatorBytes() {\n  return getU32Encoder().encode(DEACTIVATE_DELINQUENT_DISCRIMINATOR);\n}\n\nexport type DeactivateDelinquentInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountStake extends string | AccountMeta<string> = string,\n  TAccountDelinquentVote extends string | AccountMeta<string> = string,\n  TAccountReferenceVote extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountStake extends string\n        ? WritableAccount<TAccountStake>\n        : TAccountStake,\n      TAccountDelinquentVote extends string\n        ? ReadonlyAccount<TAccountDelinquentVote>\n        : TAccountDelinquentVote,\n      TAccountReferenceVote extends string\n        ? ReadonlyAccount<TAccountReferenceVote>\n        : TAccountReferenceVote,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type DeactivateDelinquentInstructionData = { discriminator: number };\n\nexport type DeactivateDelinquentInstructionDataArgs = {};\n\nexport function getDeactivateDelinquentInstructionDataEncoder(): FixedSizeEncoder<DeactivateDelinquentInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU32Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: DEACTIVATE_DELINQUENT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getDeactivateDelinquentInstructionDataDecoder(): FixedSizeDecoder<DeactivateDelinquentInstructionData> {\n  return getStructDecoder([['discriminator', getU32Decoder()]]);\n}\n\nexport function getDeactivateDelinquentInstructionDataCodec(): FixedSizeCodec<\n  DeactivateDelinquentInstructionDataArgs,\n  DeactivateDelinquentInstructionData\n> {\n  return combineCodec(\n    getDeactivateDelinquentInstructionDataEncoder(),\n    getDeactivateDelinquentInstructionDataDecoder()\n  );\n}\n\nexport type DeactivateDelinquentInput<\n  TAccountStake extends string = string,\n  TAccountDelinquentVote extends string = string,\n  TAccountReferenceVote extends string = string,\n> = {\n  /** Delegated stake account */\n  stake: Address<TAccountStake>;\n  /** Delinquent vote account */\n  delinquentVote: Address<TAccountDelinquentVote>;\n  /** Reference vote account */\n  referenceVote: Address<TAccountReferenceVote>;\n};\n\nexport function getDeactivateDelinquentInstruction<\n  TAccountStake extends string,\n  TAccountDelinquentVote extends string,\n  TAccountReferenceVote extends string,\n  TProgramAddress extends Address = typeof STAKE_PROGRAM_ADDRESS,\n>(\n  input: DeactivateDelinquentInput<\n    TAccountStake,\n    TAccountDelinquentVote,\n    TAccountReferenceVote\n  >,\n  config?: { programAddress?: TProgramAddress }\n): DeactivateDelinquentInstruction<\n  TProgramAddress,\n  TAccountStake,\n  TAccountDelinquentVote,\n  TAccountReferenceVote\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? STAKE_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    stake: { value: input.stake ?? null, isWritable: true },\n    delinquentVote: { value: input.delinquentVote ?? null, isWritable: false },\n    referenceVote: { value: input.referenceVote ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.stake),\n      getAccountMeta(accounts.delinquentVote),\n      getAccountMeta(accounts.referenceVote),\n    ],\n    data: getDeactivateDelinquentInstructionDataEncoder().encode({}),\n    programAddress,\n  } as DeactivateDelinquentInstruction<\n    TProgramAddress,\n    TAccountStake,\n    TAccountDelinquentVote,\n    TAccountReferenceVote\n  >);\n}\n\nexport type ParsedDeactivateDelinquentInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Delegated stake account */\n    stake: TAccountMetas[0];\n    /** Delinquent vote account */\n    delinquentVote: TAccountMetas[1];\n    /** Reference vote account */\n    referenceVote: TAccountMetas[2];\n  };\n  data: DeactivateDelinquentInstructionData;\n};\n\nexport function parseDeactivateDelinquentInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedDeactivateDelinquentInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      stake: getNextAccount(),\n      delinquentVote: getNextAccount(),\n      referenceVote: getNextAccount(),\n    },\n    data: getDeactivateDelinquentInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { STAKE_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const DELEGATE_STAKE_DISCRIMINATOR = 2;\n\nexport function getDelegateStakeDiscriminatorBytes() {\n  return getU32Encoder().encode(DELEGATE_STAKE_DISCRIMINATOR);\n}\n\nexport type DelegateStakeInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountStake extends string | AccountMeta<string> = string,\n  TAccountVote extends string | AccountMeta<string> = string,\n  TAccountClockSysvar extends\n    | string\n    | AccountMeta<string> = 'SysvarC1ock11111111111111111111111111111111',\n  TAccountStakeHistory extends string | AccountMeta<string> = string,\n  TAccountUnused extends string | AccountMeta<string> = string,\n  TAccountStakeAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountStake extends string\n        ? WritableAccount<TAccountStake>\n        : TAccountStake,\n      TAccountVote extends string\n        ? ReadonlyAccount<TAccountVote>\n        : TAccountVote,\n      TAccountClockSysvar extends string\n        ? ReadonlyAccount<TAccountClockSysvar>\n        : TAccountClockSysvar,\n      TAccountStakeHistory extends string\n        ? ReadonlyAccount<TAccountStakeHistory>\n        : TAccountStakeHistory,\n      TAccountUnused extends string\n        ? ReadonlyAccount<TAccountUnused>\n        : TAccountUnused,\n      TAccountStakeAuthority extends string\n        ? ReadonlySignerAccount<TAccountStakeAuthority> &\n            AccountSignerMeta<TAccountStakeAuthority>\n        : TAccountStakeAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type DelegateStakeInstructionData = { discriminator: number };\n\nexport type DelegateStakeInstructionDataArgs = {};\n\nexport function getDelegateStakeInstructionDataEncoder(): FixedSizeEncoder<DelegateStakeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU32Encoder()]]),\n    (value) => ({ ...value, discriminator: DELEGATE_STAKE_DISCRIMINATOR })\n  );\n}\n\nexport function getDelegateStakeInstructionDataDecoder(): FixedSizeDecoder<DelegateStakeInstructionData> {\n  return getStructDecoder([['discriminator', getU32Decoder()]]);\n}\n\nexport function getDelegateStakeInstructionDataCodec(): FixedSizeCodec<\n  DelegateStakeInstructionDataArgs,\n  DelegateStakeInstructionData\n> {\n  return combineCodec(\n    getDelegateStakeInstructionDataEncoder(),\n    getDelegateStakeInstructionDataDecoder()\n  );\n}\n\nexport type DelegateStakeInput<\n  TAccountStake extends string = string,\n  TAccountVote extends string = string,\n  TAccountClockSysvar extends string = string,\n  TAccountStakeHistory extends string = string,\n  TAccountUnused extends string = string,\n  TAccountStakeAuthority extends string = string,\n> = {\n  /** Initialized stake account to be delegated */\n  stake: Address<TAccountStake>;\n  /** Vote account to which this stake will be delegated */\n  vote: Address<TAccountVote>;\n  /** Clock sysvar */\n  clockSysvar?: Address<TAccountClockSysvar>;\n  /** Stake history sysvar */\n  stakeHistory: Address<TAccountStakeHistory>;\n  /** Unused account, formerly the stake config */\n  unused: Address<TAccountUnused>;\n  /** Stake authority */\n  stakeAuthority: TransactionSigner<TAccountStakeAuthority>;\n};\n\nexport function getDelegateStakeInstruction<\n  TAccountStake extends string,\n  TAccountVote extends string,\n  TAccountClockSysvar extends string,\n  TAccountStakeHistory extends string,\n  TAccountUnused extends string,\n  TAccountStakeAuthority extends string,\n  TProgramAddress extends Address = typeof STAKE_PROGRAM_ADDRESS,\n>(\n  input: DelegateStakeInput<\n    TAccountStake,\n    TAccountVote,\n    TAccountClockSysvar,\n    TAccountStakeHistory,\n    TAccountUnused,\n    TAccountStakeAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): DelegateStakeInstruction<\n  TProgramAddress,\n  TAccountStake,\n  TAccountVote,\n  TAccountClockSysvar,\n  TAccountStakeHistory,\n  TAccountUnused,\n  TAccountStakeAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? STAKE_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    stake: { value: input.stake ?? null, isWritable: true },\n    vote: { value: input.vote ?? null, isWritable: false },\n    clockSysvar: { value: input.clockSysvar ?? null, isWritable: false },\n    stakeHistory: { value: input.stakeHistory ?? null, isWritable: false },\n    unused: { value: input.unused ?? null, isWritable: false },\n    stakeAuthority: { value: input.stakeAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.clockSysvar.value) {\n    accounts.clockSysvar.value =\n      'SysvarC1ock11111111111111111111111111111111' as Address<'SysvarC1ock11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.stake),\n      getAccountMeta(accounts.vote),\n      getAccountMeta(accounts.clockSysvar),\n      getAccountMeta(accounts.stakeHistory),\n      getAccountMeta(accounts.unused),\n      getAccountMeta(accounts.stakeAuthority),\n    ],\n    data: getDelegateStakeInstructionDataEncoder().encode({}),\n    programAddress,\n  } as DelegateStakeInstruction<\n    TProgramAddress,\n    TAccountStake,\n    TAccountVote,\n    TAccountClockSysvar,\n    TAccountStakeHistory,\n    TAccountUnused,\n    TAccountStakeAuthority\n  >);\n}\n\nexport type ParsedDelegateStakeInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Initialized stake account to be delegated */\n    stake: TAccountMetas[0];\n    /** Vote account to which this stake will be delegated */\n    vote: TAccountMetas[1];\n    /** Clock sysvar */\n    clockSysvar: TAccountMetas[2];\n    /** Stake history sysvar */\n    stakeHistory: TAccountMetas[3];\n    /** Unused account, formerly the stake config */\n    unused: TAccountMetas[4];\n    /** Stake authority */\n    stakeAuthority: TAccountMetas[5];\n  };\n  data: DelegateStakeInstructionData;\n};\n\nexport function parseDelegateStakeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedDelegateStakeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 6) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      stake: getNextAccount(),\n      vote: getNextAccount(),\n      clockSysvar: getNextAccount(),\n      stakeHistory: getNextAccount(),\n      unused: getNextAccount(),\n      stakeAuthority: getNextAccount(),\n    },\n    data: getDelegateStakeInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport { STAKE_PROGRAM_ADDRESS } from '../programs';\n\nexport const GET_MINIMUM_DELEGATION_DISCRIMINATOR = 13;\n\nexport function getGetMinimumDelegationDiscriminatorBytes() {\n  return getU32Encoder().encode(GET_MINIMUM_DELEGATION_DISCRIMINATOR);\n}\n\nexport type GetMinimumDelegationInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<TRemainingAccounts>;\n\nexport type GetMinimumDelegationInstructionData = { discriminator: number };\n\nexport type GetMinimumDelegationInstructionDataArgs = {};\n\nexport function getGetMinimumDelegationInstructionDataEncoder(): FixedSizeEncoder<GetMinimumDelegationInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU32Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: GET_MINIMUM_DELEGATION_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getGetMinimumDelegationInstructionDataDecoder(): FixedSizeDecoder<GetMinimumDelegationInstructionData> {\n  return getStructDecoder([['discriminator', getU32Decoder()]]);\n}\n\nexport function getGetMinimumDelegationInstructionDataCodec(): FixedSizeCodec<\n  GetMinimumDelegationInstructionDataArgs,\n  GetMinimumDelegationInstructionData\n> {\n  return combineCodec(\n    getGetMinimumDelegationInstructionDataEncoder(),\n    getGetMinimumDelegationInstructionDataDecoder()\n  );\n}\n\nexport type GetMinimumDelegationInput = {};\n\nexport function getGetMinimumDelegationInstruction<\n  TProgramAddress extends Address = typeof STAKE_PROGRAM_ADDRESS,\n>(config?: {\n  programAddress?: TProgramAddress;\n}): GetMinimumDelegationInstruction<TProgramAddress> {\n  // Program address.\n  const programAddress = config?.programAddress ?? STAKE_PROGRAM_ADDRESS;\n\n  return Object.freeze({\n    data: getGetMinimumDelegationInstructionDataEncoder().encode({}),\n    programAddress,\n  } as GetMinimumDelegationInstruction<TProgramAddress>);\n}\n\nexport type ParsedGetMinimumDelegationInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n> = {\n  programAddress: Address<TProgram>;\n  data: GetMinimumDelegationInstructionData;\n};\n\nexport function parseGetMinimumDelegationInstruction<TProgram extends string>(\n  instruction: Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array>\n): ParsedGetMinimumDelegationInstruction<TProgram> {\n  return {\n    programAddress: instruction.programAddress,\n    data: getGetMinimumDelegationInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { STAKE_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getAuthorizedDecoder,\n  getAuthorizedEncoder,\n  getLockupDecoder,\n  getLockupEncoder,\n  type Authorized,\n  type AuthorizedArgs,\n  type Lockup,\n  type LockupArgs,\n} from '../types';\n\nexport const INITIALIZE_DISCRIMINATOR = 0;\n\nexport function getInitializeDiscriminatorBytes() {\n  return getU32Encoder().encode(INITIALIZE_DISCRIMINATOR);\n}\n\nexport type InitializeInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountStake extends string | AccountMeta<string> = string,\n  TAccountRentSysvar extends\n    | string\n    | AccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountStake extends string\n        ? WritableAccount<TAccountStake>\n        : TAccountStake,\n      TAccountRentSysvar extends string\n        ? ReadonlyAccount<TAccountRentSysvar>\n        : TAccountRentSysvar,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeInstructionData = {\n  discriminator: number;\n  arg0: Authorized;\n  arg1: Lockup;\n};\n\nexport type InitializeInstructionDataArgs = {\n  arg0: AuthorizedArgs;\n  arg1: LockupArgs;\n};\n\nexport function getInitializeInstructionDataEncoder(): FixedSizeEncoder<InitializeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['arg0', getAuthorizedEncoder()],\n      ['arg1', getLockupEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeInstructionDataDecoder(): FixedSizeDecoder<InitializeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['arg0', getAuthorizedDecoder()],\n    ['arg1', getLockupDecoder()],\n  ]);\n}\n\nexport function getInitializeInstructionDataCodec(): FixedSizeCodec<\n  InitializeInstructionDataArgs,\n  InitializeInstructionData\n> {\n  return combineCodec(\n    getInitializeInstructionDataEncoder(),\n    getInitializeInstructionDataDecoder()\n  );\n}\n\nexport type InitializeInput<\n  TAccountStake extends string = string,\n  TAccountRentSysvar extends string = string,\n> = {\n  /** Uninitialized stake account */\n  stake: Address<TAccountStake>;\n  /** Rent sysvar */\n  rentSysvar?: Address<TAccountRentSysvar>;\n  arg0: InitializeInstructionDataArgs['arg0'];\n  arg1: InitializeInstructionDataArgs['arg1'];\n};\n\nexport function getInitializeInstruction<\n  TAccountStake extends string,\n  TAccountRentSysvar extends string,\n  TProgramAddress extends Address = typeof STAKE_PROGRAM_ADDRESS,\n>(\n  input: InitializeInput<TAccountStake, TAccountRentSysvar>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeInstruction<TProgramAddress, TAccountStake, TAccountRentSysvar> {\n  // Program address.\n  const programAddress = config?.programAddress ?? STAKE_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    stake: { value: input.stake ?? null, isWritable: true },\n    rentSysvar: { value: input.rentSysvar ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.rentSysvar.value) {\n    accounts.rentSysvar.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.stake),\n      getAccountMeta(accounts.rentSysvar),\n    ],\n    data: getInitializeInstructionDataEncoder().encode(\n      args as InitializeInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeInstruction<\n    TProgramAddress,\n    TAccountStake,\n    TAccountRentSysvar\n  >);\n}\n\nexport type ParsedInitializeInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Uninitialized stake account */\n    stake: TAccountMetas[0];\n    /** Rent sysvar */\n    rentSysvar: TAccountMetas[1];\n  };\n  data: InitializeInstructionData;\n};\n\nexport function parseInitializeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { stake: getNextAccount(), rentSysvar: getNextAccount() },\n    data: getInitializeInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { STAKE_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_CHECKED_DISCRIMINATOR = 9;\n\nexport function getInitializeCheckedDiscriminatorBytes() {\n  return getU32Encoder().encode(INITIALIZE_CHECKED_DISCRIMINATOR);\n}\n\nexport type InitializeCheckedInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountStake extends string | AccountMeta<string> = string,\n  TAccountRentSysvar extends\n    | string\n    | AccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TAccountStakeAuthority extends string | AccountMeta<string> = string,\n  TAccountWithdrawAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountStake extends string\n        ? WritableAccount<TAccountStake>\n        : TAccountStake,\n      TAccountRentSysvar extends string\n        ? ReadonlyAccount<TAccountRentSysvar>\n        : TAccountRentSysvar,\n      TAccountStakeAuthority extends string\n        ? ReadonlyAccount<TAccountStakeAuthority>\n        : TAccountStakeAuthority,\n      TAccountWithdrawAuthority extends string\n        ? ReadonlySignerAccount<TAccountWithdrawAuthority> &\n            AccountSignerMeta<TAccountWithdrawAuthority>\n        : TAccountWithdrawAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeCheckedInstructionData = { discriminator: number };\n\nexport type InitializeCheckedInstructionDataArgs = {};\n\nexport function getInitializeCheckedInstructionDataEncoder(): FixedSizeEncoder<InitializeCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU32Encoder()]]),\n    (value) => ({ ...value, discriminator: INITIALIZE_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeCheckedInstructionDataDecoder(): FixedSizeDecoder<InitializeCheckedInstructionData> {\n  return getStructDecoder([['discriminator', getU32Decoder()]]);\n}\n\nexport function getInitializeCheckedInstructionDataCodec(): FixedSizeCodec<\n  InitializeCheckedInstructionDataArgs,\n  InitializeCheckedInstructionData\n> {\n  return combineCodec(\n    getInitializeCheckedInstructionDataEncoder(),\n    getInitializeCheckedInstructionDataDecoder()\n  );\n}\n\nexport type InitializeCheckedInput<\n  TAccountStake extends string = string,\n  TAccountRentSysvar extends string = string,\n  TAccountStakeAuthority extends string = string,\n  TAccountWithdrawAuthority extends string = string,\n> = {\n  /** Uninitialized stake account */\n  stake: Address<TAccountStake>;\n  /** Rent sysvar */\n  rentSysvar?: Address<TAccountRentSysvar>;\n  /** The stake authority */\n  stakeAuthority: Address<TAccountStakeAuthority>;\n  /** The withdraw authority */\n  withdrawAuthority: TransactionSigner<TAccountWithdrawAuthority>;\n};\n\nexport function getInitializeCheckedInstruction<\n  TAccountStake extends string,\n  TAccountRentSysvar extends string,\n  TAccountStakeAuthority extends string,\n  TAccountWithdrawAuthority extends string,\n  TProgramAddress extends Address = typeof STAKE_PROGRAM_ADDRESS,\n>(\n  input: InitializeCheckedInput<\n    TAccountStake,\n    TAccountRentSysvar,\n    TAccountStakeAuthority,\n    TAccountWithdrawAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeCheckedInstruction<\n  TProgramAddress,\n  TAccountStake,\n  TAccountRentSysvar,\n  TAccountStakeAuthority,\n  TAccountWithdrawAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? STAKE_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    stake: { value: input.stake ?? null, isWritable: true },\n    rentSysvar: { value: input.rentSysvar ?? null, isWritable: false },\n    stakeAuthority: { value: input.stakeAuthority ?? null, isWritable: false },\n    withdrawAuthority: {\n      value: input.withdrawAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.rentSysvar.value) {\n    accounts.rentSysvar.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.stake),\n      getAccountMeta(accounts.rentSysvar),\n      getAccountMeta(accounts.stakeAuthority),\n      getAccountMeta(accounts.withdrawAuthority),\n    ],\n    data: getInitializeCheckedInstructionDataEncoder().encode({}),\n    programAddress,\n  } as InitializeCheckedInstruction<\n    TProgramAddress,\n    TAccountStake,\n    TAccountRentSysvar,\n    TAccountStakeAuthority,\n    TAccountWithdrawAuthority\n  >);\n}\n\nexport type ParsedInitializeCheckedInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Uninitialized stake account */\n    stake: TAccountMetas[0];\n    /** Rent sysvar */\n    rentSysvar: TAccountMetas[1];\n    /** The stake authority */\n    stakeAuthority: TAccountMetas[2];\n    /** The withdraw authority */\n    withdrawAuthority: TAccountMetas[3];\n  };\n  data: InitializeCheckedInstructionData;\n};\n\nexport function parseInitializeCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      stake: getNextAccount(),\n      rentSysvar: getNextAccount(),\n      stakeAuthority: getNextAccount(),\n      withdrawAuthority: getNextAccount(),\n    },\n    data: getInitializeCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { STAKE_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const MERGE_DISCRIMINATOR = 7;\n\nexport function getMergeDiscriminatorBytes() {\n  return getU32Encoder().encode(MERGE_DISCRIMINATOR);\n}\n\nexport type MergeInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountDestinationStake extends string | AccountMeta<string> = string,\n  TAccountSourceStake extends string | AccountMeta<string> = string,\n  TAccountClockSysvar extends\n    | string\n    | AccountMeta<string> = 'SysvarC1ock11111111111111111111111111111111',\n  TAccountStakeHistory extends string | AccountMeta<string> = string,\n  TAccountStakeAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountDestinationStake extends string\n        ? WritableAccount<TAccountDestinationStake>\n        : TAccountDestinationStake,\n      TAccountSourceStake extends string\n        ? WritableAccount<TAccountSourceStake>\n        : TAccountSourceStake,\n      TAccountClockSysvar extends string\n        ? ReadonlyAccount<TAccountClockSysvar>\n        : TAccountClockSysvar,\n      TAccountStakeHistory extends string\n        ? ReadonlyAccount<TAccountStakeHistory>\n        : TAccountStakeHistory,\n      TAccountStakeAuthority extends string\n        ? ReadonlySignerAccount<TAccountStakeAuthority> &\n            AccountSignerMeta<TAccountStakeAuthority>\n        : TAccountStakeAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type MergeInstructionData = { discriminator: number };\n\nexport type MergeInstructionDataArgs = {};\n\nexport function getMergeInstructionDataEncoder(): FixedSizeEncoder<MergeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU32Encoder()]]),\n    (value) => ({ ...value, discriminator: MERGE_DISCRIMINATOR })\n  );\n}\n\nexport function getMergeInstructionDataDecoder(): FixedSizeDecoder<MergeInstructionData> {\n  return getStructDecoder([['discriminator', getU32Decoder()]]);\n}\n\nexport function getMergeInstructionDataCodec(): FixedSizeCodec<\n  MergeInstructionDataArgs,\n  MergeInstructionData\n> {\n  return combineCodec(\n    getMergeInstructionDataEncoder(),\n    getMergeInstructionDataDecoder()\n  );\n}\n\nexport type MergeInput<\n  TAccountDestinationStake extends string = string,\n  TAccountSourceStake extends string = string,\n  TAccountClockSysvar extends string = string,\n  TAccountStakeHistory extends string = string,\n  TAccountStakeAuthority extends string = string,\n> = {\n  /** Destination stake account */\n  destinationStake: Address<TAccountDestinationStake>;\n  /** Source stake account */\n  sourceStake: Address<TAccountSourceStake>;\n  /** Clock sysvar */\n  clockSysvar?: Address<TAccountClockSysvar>;\n  /** Stake history sysvar */\n  stakeHistory: Address<TAccountStakeHistory>;\n  /** Stake authority */\n  stakeAuthority: TransactionSigner<TAccountStakeAuthority>;\n};\n\nexport function getMergeInstruction<\n  TAccountDestinationStake extends string,\n  TAccountSourceStake extends string,\n  TAccountClockSysvar extends string,\n  TAccountStakeHistory extends string,\n  TAccountStakeAuthority extends string,\n  TProgramAddress extends Address = typeof STAKE_PROGRAM_ADDRESS,\n>(\n  input: MergeInput<\n    TAccountDestinationStake,\n    TAccountSourceStake,\n    TAccountClockSysvar,\n    TAccountStakeHistory,\n    TAccountStakeAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): MergeInstruction<\n  TProgramAddress,\n  TAccountDestinationStake,\n  TAccountSourceStake,\n  TAccountClockSysvar,\n  TAccountStakeHistory,\n  TAccountStakeAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? STAKE_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    destinationStake: {\n      value: input.destinationStake ?? null,\n      isWritable: true,\n    },\n    sourceStake: { value: input.sourceStake ?? null, isWritable: true },\n    clockSysvar: { value: input.clockSysvar ?? null, isWritable: false },\n    stakeHistory: { value: input.stakeHistory ?? null, isWritable: false },\n    stakeAuthority: { value: input.stakeAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.clockSysvar.value) {\n    accounts.clockSysvar.value =\n      'SysvarC1ock11111111111111111111111111111111' as Address<'SysvarC1ock11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.destinationStake),\n      getAccountMeta(accounts.sourceStake),\n      getAccountMeta(accounts.clockSysvar),\n      getAccountMeta(accounts.stakeHistory),\n      getAccountMeta(accounts.stakeAuthority),\n    ],\n    data: getMergeInstructionDataEncoder().encode({}),\n    programAddress,\n  } as MergeInstruction<\n    TProgramAddress,\n    TAccountDestinationStake,\n    TAccountSourceStake,\n    TAccountClockSysvar,\n    TAccountStakeHistory,\n    TAccountStakeAuthority\n  >);\n}\n\nexport type ParsedMergeInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Destination stake account */\n    destinationStake: TAccountMetas[0];\n    /** Source stake account */\n    sourceStake: TAccountMetas[1];\n    /** Clock sysvar */\n    clockSysvar: TAccountMetas[2];\n    /** Stake history sysvar */\n    stakeHistory: TAccountMetas[3];\n    /** Stake authority */\n    stakeAuthority: TAccountMetas[4];\n  };\n  data: MergeInstructionData;\n};\n\nexport function parseMergeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedMergeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 5) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      destinationStake: getNextAccount(),\n      sourceStake: getNextAccount(),\n      clockSysvar: getNextAccount(),\n      stakeHistory: getNextAccount(),\n      stakeAuthority: getNextAccount(),\n    },\n    data: getMergeInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { STAKE_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const MOVE_LAMPORTS_DISCRIMINATOR = 17;\n\nexport function getMoveLamportsDiscriminatorBytes() {\n  return getU32Encoder().encode(MOVE_LAMPORTS_DISCRIMINATOR);\n}\n\nexport type MoveLamportsInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountSourceStake extends string | AccountMeta<string> = string,\n  TAccountDestinationStake extends string | AccountMeta<string> = string,\n  TAccountStakeAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSourceStake extends string\n        ? WritableAccount<TAccountSourceStake>\n        : TAccountSourceStake,\n      TAccountDestinationStake extends string\n        ? WritableAccount<TAccountDestinationStake>\n        : TAccountDestinationStake,\n      TAccountStakeAuthority extends string\n        ? ReadonlySignerAccount<TAccountStakeAuthority> &\n            AccountSignerMeta<TAccountStakeAuthority>\n        : TAccountStakeAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type MoveLamportsInstructionData = {\n  discriminator: number;\n  args: bigint;\n};\n\nexport type MoveLamportsInstructionDataArgs = { args: number | bigint };\n\nexport function getMoveLamportsInstructionDataEncoder(): FixedSizeEncoder<MoveLamportsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['args', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: MOVE_LAMPORTS_DISCRIMINATOR })\n  );\n}\n\nexport function getMoveLamportsInstructionDataDecoder(): FixedSizeDecoder<MoveLamportsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['args', getU64Decoder()],\n  ]);\n}\n\nexport function getMoveLamportsInstructionDataCodec(): FixedSizeCodec<\n  MoveLamportsInstructionDataArgs,\n  MoveLamportsInstructionData\n> {\n  return combineCodec(\n    getMoveLamportsInstructionDataEncoder(),\n    getMoveLamportsInstructionDataDecoder()\n  );\n}\n\nexport type MoveLamportsInput<\n  TAccountSourceStake extends string = string,\n  TAccountDestinationStake extends string = string,\n  TAccountStakeAuthority extends string = string,\n> = {\n  /** Active or inactive source stake account */\n  sourceStake: Address<TAccountSourceStake>;\n  /** Mergeable destination stake account */\n  destinationStake: Address<TAccountDestinationStake>;\n  /** Stake authority */\n  stakeAuthority: TransactionSigner<TAccountStakeAuthority>;\n  args: MoveLamportsInstructionDataArgs['args'];\n};\n\nexport function getMoveLamportsInstruction<\n  TAccountSourceStake extends string,\n  TAccountDestinationStake extends string,\n  TAccountStakeAuthority extends string,\n  TProgramAddress extends Address = typeof STAKE_PROGRAM_ADDRESS,\n>(\n  input: MoveLamportsInput<\n    TAccountSourceStake,\n    TAccountDestinationStake,\n    TAccountStakeAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): MoveLamportsInstruction<\n  TProgramAddress,\n  TAccountSourceStake,\n  TAccountDestinationStake,\n  TAccountStakeAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? STAKE_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    sourceStake: { value: input.sourceStake ?? null, isWritable: true },\n    destinationStake: {\n      value: input.destinationStake ?? null,\n      isWritable: true,\n    },\n    stakeAuthority: { value: input.stakeAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.sourceStake),\n      getAccountMeta(accounts.destinationStake),\n      getAccountMeta(accounts.stakeAuthority),\n    ],\n    data: getMoveLamportsInstructionDataEncoder().encode(\n      args as MoveLamportsInstructionDataArgs\n    ),\n    programAddress,\n  } as MoveLamportsInstruction<\n    TProgramAddress,\n    TAccountSourceStake,\n    TAccountDestinationStake,\n    TAccountStakeAuthority\n  >);\n}\n\nexport type ParsedMoveLamportsInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Active or inactive source stake account */\n    sourceStake: TAccountMetas[0];\n    /** Mergeable destination stake account */\n    destinationStake: TAccountMetas[1];\n    /** Stake authority */\n    stakeAuthority: TAccountMetas[2];\n  };\n  data: MoveLamportsInstructionData;\n};\n\nexport function parseMoveLamportsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedMoveLamportsInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      sourceStake: getNextAccount(),\n      destinationStake: getNextAccount(),\n      stakeAuthority: getNextAccount(),\n    },\n    data: getMoveLamportsInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { STAKE_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const MOVE_STAKE_DISCRIMINATOR = 16;\n\nexport function getMoveStakeDiscriminatorBytes() {\n  return getU32Encoder().encode(MOVE_STAKE_DISCRIMINATOR);\n}\n\nexport type MoveStakeInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountSourceStake extends string | AccountMeta<string> = string,\n  TAccountDestinationStake extends string | AccountMeta<string> = string,\n  TAccountStakeAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSourceStake extends string\n        ? WritableAccount<TAccountSourceStake>\n        : TAccountSourceStake,\n      TAccountDestinationStake extends string\n        ? WritableAccount<TAccountDestinationStake>\n        : TAccountDestinationStake,\n      TAccountStakeAuthority extends string\n        ? ReadonlySignerAccount<TAccountStakeAuthority> &\n            AccountSignerMeta<TAccountStakeAuthority>\n        : TAccountStakeAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type MoveStakeInstructionData = { discriminator: number; args: bigint };\n\nexport type MoveStakeInstructionDataArgs = { args: number | bigint };\n\nexport function getMoveStakeInstructionDataEncoder(): FixedSizeEncoder<MoveStakeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['args', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: MOVE_STAKE_DISCRIMINATOR })\n  );\n}\n\nexport function getMoveStakeInstructionDataDecoder(): FixedSizeDecoder<MoveStakeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['args', getU64Decoder()],\n  ]);\n}\n\nexport function getMoveStakeInstructionDataCodec(): FixedSizeCodec<\n  MoveStakeInstructionDataArgs,\n  MoveStakeInstructionData\n> {\n  return combineCodec(\n    getMoveStakeInstructionDataEncoder(),\n    getMoveStakeInstructionDataDecoder()\n  );\n}\n\nexport type MoveStakeInput<\n  TAccountSourceStake extends string = string,\n  TAccountDestinationStake extends string = string,\n  TAccountStakeAuthority extends string = string,\n> = {\n  /** Active source stake account */\n  sourceStake: Address<TAccountSourceStake>;\n  /** Active or inactive destination stake account */\n  destinationStake: Address<TAccountDestinationStake>;\n  /** Stake authority */\n  stakeAuthority: TransactionSigner<TAccountStakeAuthority>;\n  args: MoveStakeInstructionDataArgs['args'];\n};\n\nexport function getMoveStakeInstruction<\n  TAccountSourceStake extends string,\n  TAccountDestinationStake extends string,\n  TAccountStakeAuthority extends string,\n  TProgramAddress extends Address = typeof STAKE_PROGRAM_ADDRESS,\n>(\n  input: MoveStakeInput<\n    TAccountSourceStake,\n    TAccountDestinationStake,\n    TAccountStakeAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): MoveStakeInstruction<\n  TProgramAddress,\n  TAccountSourceStake,\n  TAccountDestinationStake,\n  TAccountStakeAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? STAKE_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    sourceStake: { value: input.sourceStake ?? null, isWritable: true },\n    destinationStake: {\n      value: input.destinationStake ?? null,\n      isWritable: true,\n    },\n    stakeAuthority: { value: input.stakeAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.sourceStake),\n      getAccountMeta(accounts.destinationStake),\n      getAccountMeta(accounts.stakeAuthority),\n    ],\n    data: getMoveStakeInstructionDataEncoder().encode(\n      args as MoveStakeInstructionDataArgs\n    ),\n    programAddress,\n  } as MoveStakeInstruction<\n    TProgramAddress,\n    TAccountSourceStake,\n    TAccountDestinationStake,\n    TAccountStakeAuthority\n  >);\n}\n\nexport type ParsedMoveStakeInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Active source stake account */\n    sourceStake: TAccountMetas[0];\n    /** Active or inactive destination stake account */\n    destinationStake: TAccountMetas[1];\n    /** Stake authority */\n    stakeAuthority: TAccountMetas[2];\n  };\n  data: MoveStakeInstructionData;\n};\n\nexport function parseMoveStakeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedMoveStakeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      sourceStake: getNextAccount(),\n      destinationStake: getNextAccount(),\n      stakeAuthority: getNextAccount(),\n    },\n    data: getMoveStakeInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getI64Decoder,\n  getI64Encoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { STAKE_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SET_LOCKUP_DISCRIMINATOR = 6;\n\nexport function getSetLockupDiscriminatorBytes() {\n  return getU32Encoder().encode(SET_LOCKUP_DISCRIMINATOR);\n}\n\nexport type SetLockupInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountStake extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountStake extends string\n        ? WritableAccount<TAccountStake>\n        : TAccountStake,\n      TAccountAuthority extends string\n        ? ReadonlySignerAccount<TAccountAuthority> &\n            AccountSignerMeta<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetLockupInstructionData = {\n  discriminator: number;\n  unixTimestamp: Option<bigint>;\n  epoch: Option<bigint>;\n  custodian: Option<Address>;\n};\n\nexport type SetLockupInstructionDataArgs = {\n  unixTimestamp: OptionOrNullable<number | bigint>;\n  epoch: OptionOrNullable<number | bigint>;\n  custodian: OptionOrNullable<Address>;\n};\n\nexport function getSetLockupInstructionDataEncoder(): Encoder<SetLockupInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['unixTimestamp', getOptionEncoder(getI64Encoder())],\n      ['epoch', getOptionEncoder(getU64Encoder())],\n      ['custodian', getOptionEncoder(getAddressEncoder())],\n    ]),\n    (value) => ({ ...value, discriminator: SET_LOCKUP_DISCRIMINATOR })\n  );\n}\n\nexport function getSetLockupInstructionDataDecoder(): Decoder<SetLockupInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['unixTimestamp', getOptionDecoder(getI64Decoder())],\n    ['epoch', getOptionDecoder(getU64Decoder())],\n    ['custodian', getOptionDecoder(getAddressDecoder())],\n  ]);\n}\n\nexport function getSetLockupInstructionDataCodec(): Codec<\n  SetLockupInstructionDataArgs,\n  SetLockupInstructionData\n> {\n  return combineCodec(\n    getSetLockupInstructionDataEncoder(),\n    getSetLockupInstructionDataDecoder()\n  );\n}\n\nexport type SetLockupInput<\n  TAccountStake extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** Initialized stake account */\n  stake: Address<TAccountStake>;\n  /** Lockup authority or withdraw authority */\n  authority: TransactionSigner<TAccountAuthority>;\n  unixTimestamp: SetLockupInstructionDataArgs['unixTimestamp'];\n  epoch: SetLockupInstructionDataArgs['epoch'];\n  custodian: SetLockupInstructionDataArgs['custodian'];\n};\n\nexport function getSetLockupInstruction<\n  TAccountStake extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof STAKE_PROGRAM_ADDRESS,\n>(\n  input: SetLockupInput<TAccountStake, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): SetLockupInstruction<TProgramAddress, TAccountStake, TAccountAuthority> {\n  // Program address.\n  const programAddress = config?.programAddress ?? STAKE_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    stake: { value: input.stake ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.stake),\n      getAccountMeta(accounts.authority),\n    ],\n    data: getSetLockupInstructionDataEncoder().encode(\n      args as SetLockupInstructionDataArgs\n    ),\n    programAddress,\n  } as SetLockupInstruction<TProgramAddress, TAccountStake, TAccountAuthority>);\n}\n\nexport type ParsedSetLockupInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Initialized stake account */\n    stake: TAccountMetas[0];\n    /** Lockup authority or withdraw authority */\n    authority: TAccountMetas[1];\n  };\n  data: SetLockupInstructionData;\n};\n\nexport function parseSetLockupInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedSetLockupInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { stake: getNextAccount(), authority: getNextAccount() },\n    data: getSetLockupInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getI64Decoder,\n  getI64Encoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { STAKE_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SET_LOCKUP_CHECKED_DISCRIMINATOR = 12;\n\nexport function getSetLockupCheckedDiscriminatorBytes() {\n  return getU32Encoder().encode(SET_LOCKUP_CHECKED_DISCRIMINATOR);\n}\n\nexport type SetLockupCheckedInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountStake extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TAccountNewAuthority extends\n    | string\n    | AccountMeta<string>\n    | undefined = undefined,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountStake extends string\n        ? WritableAccount<TAccountStake>\n        : TAccountStake,\n      TAccountAuthority extends string\n        ? ReadonlySignerAccount<TAccountAuthority> &\n            AccountSignerMeta<TAccountAuthority>\n        : TAccountAuthority,\n      ...(TAccountNewAuthority extends undefined\n        ? []\n        : [\n            TAccountNewAuthority extends string\n              ? ReadonlySignerAccount<TAccountNewAuthority> &\n                  AccountSignerMeta<TAccountNewAuthority>\n              : TAccountNewAuthority,\n          ]),\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetLockupCheckedInstructionData = {\n  discriminator: number;\n  unixTimestamp: Option<bigint>;\n  epoch: Option<bigint>;\n};\n\nexport type SetLockupCheckedInstructionDataArgs = {\n  unixTimestamp: OptionOrNullable<number | bigint>;\n  epoch: OptionOrNullable<number | bigint>;\n};\n\nexport function getSetLockupCheckedInstructionDataEncoder(): Encoder<SetLockupCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['unixTimestamp', getOptionEncoder(getI64Encoder())],\n      ['epoch', getOptionEncoder(getU64Encoder())],\n    ]),\n    (value) => ({ ...value, discriminator: SET_LOCKUP_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getSetLockupCheckedInstructionDataDecoder(): Decoder<SetLockupCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['unixTimestamp', getOptionDecoder(getI64Decoder())],\n    ['epoch', getOptionDecoder(getU64Decoder())],\n  ]);\n}\n\nexport function getSetLockupCheckedInstructionDataCodec(): Codec<\n  SetLockupCheckedInstructionDataArgs,\n  SetLockupCheckedInstructionData\n> {\n  return combineCodec(\n    getSetLockupCheckedInstructionDataEncoder(),\n    getSetLockupCheckedInstructionDataDecoder()\n  );\n}\n\nexport type SetLockupCheckedInput<\n  TAccountStake extends string = string,\n  TAccountAuthority extends string = string,\n  TAccountNewAuthority extends string = string,\n> = {\n  /** Initialized stake account */\n  stake: Address<TAccountStake>;\n  /** Lockup authority or withdraw authority */\n  authority: TransactionSigner<TAccountAuthority>;\n  /** New lockup authority */\n  newAuthority?: TransactionSigner<TAccountNewAuthority>;\n  unixTimestamp: SetLockupCheckedInstructionDataArgs['unixTimestamp'];\n  epoch: SetLockupCheckedInstructionDataArgs['epoch'];\n};\n\nexport function getSetLockupCheckedInstruction<\n  TAccountStake extends string,\n  TAccountAuthority extends string,\n  TAccountNewAuthority extends string,\n  TProgramAddress extends Address = typeof STAKE_PROGRAM_ADDRESS,\n>(\n  input: SetLockupCheckedInput<\n    TAccountStake,\n    TAccountAuthority,\n    TAccountNewAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): SetLockupCheckedInstruction<\n  TProgramAddress,\n  TAccountStake,\n  TAccountAuthority,\n  TAccountNewAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? STAKE_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    stake: { value: input.stake ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n    newAuthority: { value: input.newAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.stake),\n      getAccountMeta(accounts.authority),\n      getAccountMeta(accounts.newAuthority),\n    ].filter(<T>(x: T | undefined): x is T => x !== undefined),\n    data: getSetLockupCheckedInstructionDataEncoder().encode(\n      args as SetLockupCheckedInstructionDataArgs\n    ),\n    programAddress,\n  } as SetLockupCheckedInstruction<\n    TProgramAddress,\n    TAccountStake,\n    TAccountAuthority,\n    TAccountNewAuthority\n  >);\n}\n\nexport type ParsedSetLockupCheckedInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Initialized stake account */\n    stake: TAccountMetas[0];\n    /** Lockup authority or withdraw authority */\n    authority: TAccountMetas[1];\n    /** New lockup authority */\n    newAuthority?: TAccountMetas[2] | undefined;\n  };\n  data: SetLockupCheckedInstructionData;\n};\n\nexport function parseSetLockupCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedSetLockupCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  let optionalAccountsRemaining = instruction.accounts.length - 2;\n  const getNextOptionalAccount = () => {\n    if (optionalAccountsRemaining === 0) return undefined;\n    optionalAccountsRemaining -= 1;\n    return getNextAccount();\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      stake: getNextAccount(),\n      authority: getNextAccount(),\n      newAuthority: getNextOptionalAccount(),\n    },\n    data: getSetLockupCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { STAKE_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SPLIT_DISCRIMINATOR = 3;\n\nexport function getSplitDiscriminatorBytes() {\n  return getU32Encoder().encode(SPLIT_DISCRIMINATOR);\n}\n\nexport type SplitInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountStake extends string | AccountMeta<string> = string,\n  TAccountSplitStake extends string | AccountMeta<string> = string,\n  TAccountStakeAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountStake extends string\n        ? WritableAccount<TAccountStake>\n        : TAccountStake,\n      TAccountSplitStake extends string\n        ? WritableAccount<TAccountSplitStake>\n        : TAccountSplitStake,\n      TAccountStakeAuthority extends string\n        ? ReadonlySignerAccount<TAccountStakeAuthority> &\n            AccountSignerMeta<TAccountStakeAuthority>\n        : TAccountStakeAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SplitInstructionData = { discriminator: number; args: bigint };\n\nexport type SplitInstructionDataArgs = { args: number | bigint };\n\nexport function getSplitInstructionDataEncoder(): FixedSizeEncoder<SplitInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['args', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: SPLIT_DISCRIMINATOR })\n  );\n}\n\nexport function getSplitInstructionDataDecoder(): FixedSizeDecoder<SplitInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['args', getU64Decoder()],\n  ]);\n}\n\nexport function getSplitInstructionDataCodec(): FixedSizeCodec<\n  SplitInstructionDataArgs,\n  SplitInstructionData\n> {\n  return combineCodec(\n    getSplitInstructionDataEncoder(),\n    getSplitInstructionDataDecoder()\n  );\n}\n\nexport type SplitInput<\n  TAccountStake extends string = string,\n  TAccountSplitStake extends string = string,\n  TAccountStakeAuthority extends string = string,\n> = {\n  /** Stake account to be split */\n  stake: Address<TAccountStake>;\n  /** Uninitialized stake account */\n  splitStake: Address<TAccountSplitStake>;\n  /** Stake authority */\n  stakeAuthority: TransactionSigner<TAccountStakeAuthority>;\n  args: SplitInstructionDataArgs['args'];\n};\n\nexport function getSplitInstruction<\n  TAccountStake extends string,\n  TAccountSplitStake extends string,\n  TAccountStakeAuthority extends string,\n  TProgramAddress extends Address = typeof STAKE_PROGRAM_ADDRESS,\n>(\n  input: SplitInput<TAccountStake, TAccountSplitStake, TAccountStakeAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): SplitInstruction<\n  TProgramAddress,\n  TAccountStake,\n  TAccountSplitStake,\n  TAccountStakeAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? STAKE_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    stake: { value: input.stake ?? null, isWritable: true },\n    splitStake: { value: input.splitStake ?? null, isWritable: true },\n    stakeAuthority: { value: input.stakeAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.stake),\n      getAccountMeta(accounts.splitStake),\n      getAccountMeta(accounts.stakeAuthority),\n    ],\n    data: getSplitInstructionDataEncoder().encode(\n      args as SplitInstructionDataArgs\n    ),\n    programAddress,\n  } as SplitInstruction<\n    TProgramAddress,\n    TAccountStake,\n    TAccountSplitStake,\n    TAccountStakeAuthority\n  >);\n}\n\nexport type ParsedSplitInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Stake account to be split */\n    stake: TAccountMetas[0];\n    /** Uninitialized stake account */\n    splitStake: TAccountMetas[1];\n    /** Stake authority */\n    stakeAuthority: TAccountMetas[2];\n  };\n  data: SplitInstructionData;\n};\n\nexport function parseSplitInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedSplitInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      stake: getNextAccount(),\n      splitStake: getNextAccount(),\n      stakeAuthority: getNextAccount(),\n    },\n    data: getSplitInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { STAKE_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const WITHDRAW_DISCRIMINATOR = 4;\n\nexport function getWithdrawDiscriminatorBytes() {\n  return getU32Encoder().encode(WITHDRAW_DISCRIMINATOR);\n}\n\nexport type WithdrawInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountStake extends string | AccountMeta<string> = string,\n  TAccountRecipient extends string | AccountMeta<string> = string,\n  TAccountClockSysvar extends\n    | string\n    | AccountMeta<string> = 'SysvarC1ock11111111111111111111111111111111',\n  TAccountStakeHistory extends string | AccountMeta<string> = string,\n  TAccountWithdrawAuthority extends string | AccountMeta<string> = string,\n  TAccountLockupAuthority extends\n    | string\n    | AccountMeta<string>\n    | undefined = undefined,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountStake extends string\n        ? WritableAccount<TAccountStake>\n        : TAccountStake,\n      TAccountRecipient extends string\n        ? WritableAccount<TAccountRecipient>\n        : TAccountRecipient,\n      TAccountClockSysvar extends string\n        ? ReadonlyAccount<TAccountClockSysvar>\n        : TAccountClockSysvar,\n      TAccountStakeHistory extends string\n        ? ReadonlyAccount<TAccountStakeHistory>\n        : TAccountStakeHistory,\n      TAccountWithdrawAuthority extends string\n        ? ReadonlySignerAccount<TAccountWithdrawAuthority> &\n            AccountSignerMeta<TAccountWithdrawAuthority>\n        : TAccountWithdrawAuthority,\n      ...(TAccountLockupAuthority extends undefined\n        ? []\n        : [\n            TAccountLockupAuthority extends string\n              ? ReadonlySignerAccount<TAccountLockupAuthority> &\n                  AccountSignerMeta<TAccountLockupAuthority>\n              : TAccountLockupAuthority,\n          ]),\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type WithdrawInstructionData = { discriminator: number; args: bigint };\n\nexport type WithdrawInstructionDataArgs = { args: number | bigint };\n\nexport function getWithdrawInstructionDataEncoder(): FixedSizeEncoder<WithdrawInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['args', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: WITHDRAW_DISCRIMINATOR })\n  );\n}\n\nexport function getWithdrawInstructionDataDecoder(): FixedSizeDecoder<WithdrawInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['args', getU64Decoder()],\n  ]);\n}\n\nexport function getWithdrawInstructionDataCodec(): FixedSizeCodec<\n  WithdrawInstructionDataArgs,\n  WithdrawInstructionData\n> {\n  return combineCodec(\n    getWithdrawInstructionDataEncoder(),\n    getWithdrawInstructionDataDecoder()\n  );\n}\n\nexport type WithdrawInput<\n  TAccountStake extends string = string,\n  TAccountRecipient extends string = string,\n  TAccountClockSysvar extends string = string,\n  TAccountStakeHistory extends string = string,\n  TAccountWithdrawAuthority extends string = string,\n  TAccountLockupAuthority extends string = string,\n> = {\n  /** Stake account from which to withdraw */\n  stake: Address<TAccountStake>;\n  /** Recipient account */\n  recipient: Address<TAccountRecipient>;\n  /** Clock sysvar */\n  clockSysvar?: Address<TAccountClockSysvar>;\n  /** Stake history sysvar */\n  stakeHistory: Address<TAccountStakeHistory>;\n  /** Withdraw authority */\n  withdrawAuthority: TransactionSigner<TAccountWithdrawAuthority>;\n  /** Lockup authority */\n  lockupAuthority?: TransactionSigner<TAccountLockupAuthority>;\n  args: WithdrawInstructionDataArgs['args'];\n};\n\nexport function getWithdrawInstruction<\n  TAccountStake extends string,\n  TAccountRecipient extends string,\n  TAccountClockSysvar extends string,\n  TAccountStakeHistory extends string,\n  TAccountWithdrawAuthority extends string,\n  TAccountLockupAuthority extends string,\n  TProgramAddress extends Address = typeof STAKE_PROGRAM_ADDRESS,\n>(\n  input: WithdrawInput<\n    TAccountStake,\n    TAccountRecipient,\n    TAccountClockSysvar,\n    TAccountStakeHistory,\n    TAccountWithdrawAuthority,\n    TAccountLockupAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): WithdrawInstruction<\n  TProgramAddress,\n  TAccountStake,\n  TAccountRecipient,\n  TAccountClockSysvar,\n  TAccountStakeHistory,\n  TAccountWithdrawAuthority,\n  TAccountLockupAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? STAKE_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    stake: { value: input.stake ?? null, isWritable: true },\n    recipient: { value: input.recipient ?? null, isWritable: true },\n    clockSysvar: { value: input.clockSysvar ?? null, isWritable: false },\n    stakeHistory: { value: input.stakeHistory ?? null, isWritable: false },\n    withdrawAuthority: {\n      value: input.withdrawAuthority ?? null,\n      isWritable: false,\n    },\n    lockupAuthority: {\n      value: input.lockupAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.clockSysvar.value) {\n    accounts.clockSysvar.value =\n      'SysvarC1ock11111111111111111111111111111111' as Address<'SysvarC1ock11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.stake),\n      getAccountMeta(accounts.recipient),\n      getAccountMeta(accounts.clockSysvar),\n      getAccountMeta(accounts.stakeHistory),\n      getAccountMeta(accounts.withdrawAuthority),\n      getAccountMeta(accounts.lockupAuthority),\n    ].filter(<T>(x: T | undefined): x is T => x !== undefined),\n    data: getWithdrawInstructionDataEncoder().encode(\n      args as WithdrawInstructionDataArgs\n    ),\n    programAddress,\n  } as WithdrawInstruction<\n    TProgramAddress,\n    TAccountStake,\n    TAccountRecipient,\n    TAccountClockSysvar,\n    TAccountStakeHistory,\n    TAccountWithdrawAuthority,\n    TAccountLockupAuthority\n  >);\n}\n\nexport type ParsedWithdrawInstruction<\n  TProgram extends string = typeof STAKE_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Stake account from which to withdraw */\n    stake: TAccountMetas[0];\n    /** Recipient account */\n    recipient: TAccountMetas[1];\n    /** Clock sysvar */\n    clockSysvar: TAccountMetas[2];\n    /** Stake history sysvar */\n    stakeHistory: TAccountMetas[3];\n    /** Withdraw authority */\n    withdrawAuthority: TAccountMetas[4];\n    /** Lockup authority */\n    lockupAuthority?: TAccountMetas[5] | undefined;\n  };\n  data: WithdrawInstructionData;\n};\n\nexport function parseWithdrawInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedWithdrawInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 5) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  let optionalAccountsRemaining = instruction.accounts.length - 5;\n  const getNextOptionalAccount = () => {\n    if (optionalAccountsRemaining === 0) return undefined;\n    optionalAccountsRemaining -= 1;\n    return getNextAccount();\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      stake: getNextAccount(),\n      recipient: getNextAccount(),\n      clockSysvar: getNextAccount(),\n      stakeHistory: getNextAccount(),\n      withdrawAuthority: getNextAccount(),\n      lockupAuthority: getNextOptionalAccount(),\n    },\n    data: getWithdrawInstructionDataDecoder().decode(instruction.data),\n  };\n}\n"]}