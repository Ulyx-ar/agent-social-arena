'use strict';

var kit = require('@solana/kit');
var http = require('../http.cjs');
var wrapAutoSend = require('./wrapAutoSend.cjs');
var lazy = require('./lazy.cjs');
var caller = require('./caller.cjs');
var wsAsync = require('../websockets/wsAsync.cjs');

const createHelius = ({ apiKey, network = "mainnet", rebateAddress, }) => {
    const baseUrl = `https://${network}.helius-rpc.com/`;
    const rebateParam = rebateAddress ? `&rebate-address=${rebateAddress}` : "";
    const url = `${baseUrl}?api-key=${apiKey}${rebateParam}`;
    const solanaApi = kit.createSolanaRpcApi(kit.DEFAULT_RPC_CONFIG);
    const baseTransport = kit.createDefaultRpcTransport({
        url,
        headers: { "User-Agent": http.SDK_USER_AGENT },
    });
    const transport = async (request) => {
        const payload = {
            ...request.payload,
            id: "helius-sdk",
        };
        const modifiedRequest = {
            ...request,
            payload,
        };
        return baseTransport(modifiedRequest);
    };
    const baseRpc = kit.createRpc({ api: solanaApi, transport });
    const raw = wrapAutoSend.wrapAutoSend(baseRpc);
    const wsUrl = new URL(url);
    wsUrl.protocol = "wss:";
    // Lazily create when/if transaction helpers need it
    let rpcSubscriptionsPromise;
    const getRpcSubscriptions = async () => {
        if (rpcSubscriptionsPromise)
            return rpcSubscriptionsPromise;
        const { createSolanaRpcSubscriptions } = await import('@solana/kit');
        rpcSubscriptionsPromise = createSolanaRpcSubscriptions(wsUrl.toString());
        return rpcSubscriptionsPromise;
    };
    // Lightweight, no-PendingRpcRequest caller for custom DAS/webhook methods
    const call = caller.makeRpcCaller(transport);
    // The object weâ€™ll populate lazily
    const client = { raw };
    lazy.defineLazyNamespace(client, "ws", async () => {
        // Promisified facade; individual methods return Promise<...>
        // so: await helius.ws.logsNotifications(...).subscribe(...) and no stupid TypeScript warnings
        const ws = wsAsync.makeWsAsync(wsUrl.toString());
        client.close = () => ws.close();
        return ws;
    });
    lazy.defineLazyMethod(client, "getAsset", async () => {
        const { makeGetAsset } = await Promise.resolve().then(function () { return require('./methods/getAsset.cjs'); });
        return makeGetAsset(call);
    });
    lazy.defineLazyMethod(client, "getAssetBatch", async () => {
        const { makeGetAssetBatch } = await Promise.resolve().then(function () { return require('./methods/getAssetBatch.cjs'); });
        return makeGetAssetBatch(call);
    });
    lazy.defineLazyMethod(client, "getAssetProof", async () => {
        const { makeGetAssetProof } = await Promise.resolve().then(function () { return require('./methods/getAssetProof.cjs'); });
        return makeGetAssetProof(call);
    });
    lazy.defineLazyMethod(client, "getAssetProofBatch", async () => {
        const { makeGetAssetProofBatch } = await Promise.resolve().then(function () { return require('./methods/getAssetProofBatch.cjs'); });
        return makeGetAssetProofBatch(call);
    });
    lazy.defineLazyMethod(client, "getAssetsByAuthority", async () => {
        const { makeGetAssetsByAuthority } = await Promise.resolve().then(function () { return require('./methods/getAssetsByAuthority.cjs'); });
        return makeGetAssetsByAuthority(call);
    });
    lazy.defineLazyMethod(client, "getAssetsByCreator", async () => {
        const { makeGetAssetsByCreator } = await Promise.resolve().then(function () { return require('./methods/getAssetsByCreator.cjs'); });
        return makeGetAssetsByCreator(call);
    });
    lazy.defineLazyMethod(client, "getAssetsByGroup", async () => {
        const { makeGetAssetsByGroup } = await Promise.resolve().then(function () { return require('./methods/getAssetsByGroup.cjs'); });
        return makeGetAssetsByGroup(call);
    });
    lazy.defineLazyMethod(client, "getAssetsByOwner", async () => {
        const { makeGetAssetsByOwner } = await Promise.resolve().then(function () { return require('./methods/getAssetsByOwner.cjs'); });
        return makeGetAssetsByOwner(call);
    });
    lazy.defineLazyMethod(client, "getNftEditions", async () => {
        const { makeGetNftEditions } = await Promise.resolve().then(function () { return require('./methods/getNftEditions.cjs'); });
        return makeGetNftEditions(call);
    });
    lazy.defineLazyMethod(client, "getSignaturesForAsset", async () => {
        const { makeGetSignaturesForAsset } = await Promise.resolve().then(function () { return require('./methods/getSignaturesForAsset.cjs'); });
        return makeGetSignaturesForAsset(call);
    });
    lazy.defineLazyMethod(client, "getTokenAccounts", async () => {
        const { makeGetTokenAccounts } = await Promise.resolve().then(function () { return require('./methods/getTokenAccounts.cjs'); });
        return makeGetTokenAccounts(call);
    });
    lazy.defineLazyMethod(client, "searchAssets", async () => {
        const { makeSearchAssets } = await Promise.resolve().then(function () { return require('./methods/searchAssets.cjs'); });
        return makeSearchAssets(call);
    });
    lazy.defineLazyMethod(client, "getPriorityFeeEstimate", async () => {
        const { makeGetPriorityFeeEstimate } = await Promise.resolve().then(function () { return require('./methods/getPriorityFeeEstimate.cjs'); });
        return makeGetPriorityFeeEstimate(call);
    });
    lazy.defineLazyMethod(client, "getProgramAccountsV2", async () => {
        const { makeGetProgramAccountsV2 } = await Promise.resolve().then(function () { return require('./methods/getProgramAccountsV2.cjs'); });
        return makeGetProgramAccountsV2(call);
    });
    lazy.defineLazyMethod(client, "getAllProgramAccounts", async () => {
        const { makeGetAllProgramAccounts } = await Promise.resolve().then(function () { return require('./methods/getAllProgramAccounts.cjs'); });
        return makeGetAllProgramAccounts(call);
    });
    lazy.defineLazyMethod(client, "getTokenAccountsByOwnerV2", async () => {
        const { makeGetTokenAccountsByOwnerV2 } = await Promise.resolve().then(function () { return require('./methods/getTokenAccountsByOwnerV2.cjs'); });
        return makeGetTokenAccountsByOwnerV2(call);
    });
    lazy.defineLazyMethod(client, "getAllTokenAccountsByOwner", async () => {
        const { makeGetAllTokenAccountsByOwner } = await Promise.resolve().then(function () { return require('./methods/getAllTokenAccountsByOwner.cjs'); });
        return makeGetAllTokenAccountsByOwner(call);
    });
    lazy.defineLazyMethod(client, "getTransactionsForAddress", async () => {
        const { makeGetTransactionsForAddress } = await Promise.resolve().then(function () { return require('./methods/getTransactionsForAddress.cjs'); });
        return makeGetTransactionsForAddress(call);
    });
    lazy.defineLazyNamespace(client, "webhooks", async () => {
        // This one import is enough since the sub-methods in the webhook client
        // are themselves lazily imported inside makeWebhookClient
        const { makeWebhookClient } = await Promise.resolve().then(function () { return require('../webhooks/client.cjs'); });
        return makeWebhookClient(apiKey);
    });
    lazy.defineLazyNamespace(client, "enhanced", async () => {
        const { makeEnhancedTxClientLazy } = await Promise.resolve().then(function () { return require('../enhanced/index.cjs'); });
        return makeEnhancedTxClientLazy(apiKey, network);
    });
    lazy.defineLazyNamespace(client, "tx", async () => {
        const { makeTxHelpersLazy } = await Promise.resolve().then(function () { return require('../transactions/index.cjs'); });
        const { makeGetPriorityFeeEstimate } = await Promise.resolve().then(function () { return require('./methods/getPriorityFeeEstimate.cjs'); });
        const getPriorityFeeEstimate = makeGetPriorityFeeEstimate(call);
        return makeTxHelpersLazy(baseRpc, getPriorityFeeEstimate, await getRpcSubscriptions());
    });
    lazy.defineLazyNamespace(client, "stake", async () => {
        const { makeStakeClientLazy } = await Promise.resolve().then(function () { return require('../staking/client.cjs'); });
        return makeStakeClientLazy(baseRpc);
    });
    lazy.defineLazyNamespace(client, "zk", async () => {
        const { makeZkClientLazy } = await Promise.resolve().then(function () { return require('../zk/client.cjs'); });
        return makeZkClientLazy(call);
    });
    // So we can send standard RPC calls
    const merged = new Proxy(client, {
        get(target, prop, receiver) {
            // Prefer helper / DAS / tx / webhooks / enhanced
            if (prop in target)
                return Reflect.get(target, prop, receiver);
            // Fallback to vanilla Solana RPC (already wrapped by wrapAutoSend)
            return Reflect.get(raw, prop, receiver);
        },
        has(target, prop) {
            return prop in target || prop in raw;
        },
    });
    return merged;
};

exports.createHelius = createHelius;
//# sourceMappingURL=index.cjs.map
