import { createSolanaRpcApi, DEFAULT_RPC_CONFIG, createDefaultRpcTransport, createRpc } from '@solana/kit';
import { SDK_USER_AGENT } from '../http.js';
import { wrapAutoSend } from './wrapAutoSend.js';
import { defineLazyNamespace, defineLazyMethod } from './lazy.js';
import { makeRpcCaller } from './caller.js';
import { makeWsAsync } from '../websockets/wsAsync.js';

const createHelius = ({ apiKey, network = "mainnet", rebateAddress, }) => {
    const baseUrl = `https://${network}.helius-rpc.com/`;
    const rebateParam = rebateAddress ? `&rebate-address=${rebateAddress}` : "";
    const url = `${baseUrl}?api-key=${apiKey}${rebateParam}`;
    const solanaApi = createSolanaRpcApi(DEFAULT_RPC_CONFIG);
    const baseTransport = createDefaultRpcTransport({
        url,
        headers: { "User-Agent": SDK_USER_AGENT },
    });
    const transport = async (request) => {
        const payload = {
            ...request.payload,
            id: "helius-sdk",
        };
        const modifiedRequest = {
            ...request,
            payload,
        };
        return baseTransport(modifiedRequest);
    };
    const baseRpc = createRpc({ api: solanaApi, transport });
    const raw = wrapAutoSend(baseRpc);
    const wsUrl = new URL(url);
    wsUrl.protocol = "wss:";
    // Lazily create when/if transaction helpers need it
    let rpcSubscriptionsPromise;
    const getRpcSubscriptions = async () => {
        if (rpcSubscriptionsPromise)
            return rpcSubscriptionsPromise;
        const { createSolanaRpcSubscriptions } = await import('@solana/kit');
        rpcSubscriptionsPromise = createSolanaRpcSubscriptions(wsUrl.toString());
        return rpcSubscriptionsPromise;
    };
    // Lightweight, no-PendingRpcRequest caller for custom DAS/webhook methods
    const call = makeRpcCaller(transport);
    // The object weâ€™ll populate lazily
    const client = { raw };
    defineLazyNamespace(client, "ws", async () => {
        // Promisified facade; individual methods return Promise<...>
        // so: await helius.ws.logsNotifications(...).subscribe(...) and no stupid TypeScript warnings
        const ws = makeWsAsync(wsUrl.toString());
        client.close = () => ws.close();
        return ws;
    });
    defineLazyMethod(client, "getAsset", async () => {
        const { makeGetAsset } = await import('./methods/getAsset.js');
        return makeGetAsset(call);
    });
    defineLazyMethod(client, "getAssetBatch", async () => {
        const { makeGetAssetBatch } = await import('./methods/getAssetBatch.js');
        return makeGetAssetBatch(call);
    });
    defineLazyMethod(client, "getAssetProof", async () => {
        const { makeGetAssetProof } = await import('./methods/getAssetProof.js');
        return makeGetAssetProof(call);
    });
    defineLazyMethod(client, "getAssetProofBatch", async () => {
        const { makeGetAssetProofBatch } = await import('./methods/getAssetProofBatch.js');
        return makeGetAssetProofBatch(call);
    });
    defineLazyMethod(client, "getAssetsByAuthority", async () => {
        const { makeGetAssetsByAuthority } = await import('./methods/getAssetsByAuthority.js');
        return makeGetAssetsByAuthority(call);
    });
    defineLazyMethod(client, "getAssetsByCreator", async () => {
        const { makeGetAssetsByCreator } = await import('./methods/getAssetsByCreator.js');
        return makeGetAssetsByCreator(call);
    });
    defineLazyMethod(client, "getAssetsByGroup", async () => {
        const { makeGetAssetsByGroup } = await import('./methods/getAssetsByGroup.js');
        return makeGetAssetsByGroup(call);
    });
    defineLazyMethod(client, "getAssetsByOwner", async () => {
        const { makeGetAssetsByOwner } = await import('./methods/getAssetsByOwner.js');
        return makeGetAssetsByOwner(call);
    });
    defineLazyMethod(client, "getNftEditions", async () => {
        const { makeGetNftEditions } = await import('./methods/getNftEditions.js');
        return makeGetNftEditions(call);
    });
    defineLazyMethod(client, "getSignaturesForAsset", async () => {
        const { makeGetSignaturesForAsset } = await import('./methods/getSignaturesForAsset.js');
        return makeGetSignaturesForAsset(call);
    });
    defineLazyMethod(client, "getTokenAccounts", async () => {
        const { makeGetTokenAccounts } = await import('./methods/getTokenAccounts.js');
        return makeGetTokenAccounts(call);
    });
    defineLazyMethod(client, "searchAssets", async () => {
        const { makeSearchAssets } = await import('./methods/searchAssets.js');
        return makeSearchAssets(call);
    });
    defineLazyMethod(client, "getPriorityFeeEstimate", async () => {
        const { makeGetPriorityFeeEstimate } = await import('./methods/getPriorityFeeEstimate.js');
        return makeGetPriorityFeeEstimate(call);
    });
    defineLazyMethod(client, "getProgramAccountsV2", async () => {
        const { makeGetProgramAccountsV2 } = await import('./methods/getProgramAccountsV2.js');
        return makeGetProgramAccountsV2(call);
    });
    defineLazyMethod(client, "getAllProgramAccounts", async () => {
        const { makeGetAllProgramAccounts } = await import('./methods/getAllProgramAccounts.js');
        return makeGetAllProgramAccounts(call);
    });
    defineLazyMethod(client, "getTokenAccountsByOwnerV2", async () => {
        const { makeGetTokenAccountsByOwnerV2 } = await import('./methods/getTokenAccountsByOwnerV2.js');
        return makeGetTokenAccountsByOwnerV2(call);
    });
    defineLazyMethod(client, "getAllTokenAccountsByOwner", async () => {
        const { makeGetAllTokenAccountsByOwner } = await import('./methods/getAllTokenAccountsByOwner.js');
        return makeGetAllTokenAccountsByOwner(call);
    });
    defineLazyMethod(client, "getTransactionsForAddress", async () => {
        const { makeGetTransactionsForAddress } = await import('./methods/getTransactionsForAddress.js');
        return makeGetTransactionsForAddress(call);
    });
    defineLazyNamespace(client, "webhooks", async () => {
        // This one import is enough since the sub-methods in the webhook client
        // are themselves lazily imported inside makeWebhookClient
        const { makeWebhookClient } = await import('../webhooks/client.js');
        return makeWebhookClient(apiKey);
    });
    defineLazyNamespace(client, "enhanced", async () => {
        const { makeEnhancedTxClientLazy } = await import('../enhanced/index.js');
        return makeEnhancedTxClientLazy(apiKey, network);
    });
    defineLazyNamespace(client, "tx", async () => {
        const { makeTxHelpersLazy } = await import('../transactions/index.js');
        const { makeGetPriorityFeeEstimate } = await import('./methods/getPriorityFeeEstimate.js');
        const getPriorityFeeEstimate = makeGetPriorityFeeEstimate(call);
        return makeTxHelpersLazy(baseRpc, getPriorityFeeEstimate, await getRpcSubscriptions());
    });
    defineLazyNamespace(client, "stake", async () => {
        const { makeStakeClientLazy } = await import('../staking/client.js');
        return makeStakeClientLazy(baseRpc);
    });
    defineLazyNamespace(client, "zk", async () => {
        const { makeZkClientLazy } = await import('../zk/client.js');
        return makeZkClientLazy(call);
    });
    // So we can send standard RPC calls
    const merged = new Proxy(client, {
        get(target, prop, receiver) {
            // Prefer helper / DAS / tx / webhooks / enhanced
            if (prop in target)
                return Reflect.get(target, prop, receiver);
            // Fallback to vanilla Solana RPC (already wrapped by wrapAutoSend)
            return Reflect.get(raw, prop, receiver);
        },
        has(target, prop) {
            return prop in target || prop in raw;
        },
    });
    return merged;
};

export { createHelius };
//# sourceMappingURL=index.js.map
