/*
    A helper to define a lazily-loaded method.
    It returns a function that, on the first call, imports the real implementation
    and then caches it for all subsequent calls
*/
const defineLazyMethod = (target, key, loader) => {
    let impl;
    let loading;
    const install = (fn) => {
        impl = fn;
        // Replace the property with the resolved function so we skip the getter forever after
        Object.defineProperty(target, key, {
            configurable: true,
            enumerable: true,
            writable: false,
            value: fn,
        });
        return fn;
    };
    Object.defineProperty(target, key, {
        configurable: true,
        enumerable: true,
        get() {
            // The first time someone *reads* the property, we return a callable proxy
            const proxy = (...args) => {
                if (impl) {
                    // Wrap in Promise.resolve to normalize sync/async F
                    return Promise.resolve(impl(...args));
                }
                loading ?? (loading = loader().then(install));
                return loading.then((fn) => fn(...args));
            };
            // Replace the getter with the proxy immediately, so future reads don't hit this getter again
            Object.defineProperty(target, key, {
                configurable: true,
                enumerable: true,
                writable: false,
                value: proxy,
            });
            return proxy;
        },
    });
};
/*
    A namespace proxy whose methods are lazily executed the first time you call them.
    *I hate TypeScript*
*/
const defineLazyNamespace = (target, key, loader) => {
    let ns;
    let loading;
    const install = (impl) => {
        ns = impl;
        Object.defineProperty(target, key, {
            configurable: true,
            enumerable: true,
            writable: false,
            value: impl,
        });
        return impl;
    };
    // A proxy that defers to the resolved namespace methods
    const proxy = new Proxy({}, {
        get(_obj, prop) {
            // When you call helius.webhooks.someMethod(...),
            // we ensure the namespace is loaded, then forward the call
            return (...args) => {
                if (ns) {
                    return ns[prop](...args);
                }
                loading ?? (loading = loader().then(install));
                return loading.then((impl) => impl[prop](...args));
            };
        },
    });
    Object.defineProperty(target, key, {
        configurable: true,
        enumerable: true,
        get() {
            // Kick off loading on first *read*, but immediately return the proxy
            loading ?? (loading = loader().then(install));
            // Replace this getter so we don't run it again
            Object.defineProperty(target, key, {
                configurable: true,
                enumerable: true,
                writable: false,
                value: proxy,
            });
            return proxy;
        },
    });
};

export { defineLazyMethod, defineLazyNamespace };
//# sourceMappingURL=lazy.js.map
