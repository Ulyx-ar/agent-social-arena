{"version":3,"file":"lazy.js","sources":["../../../../src/rpc/lazy.ts"],"sourcesContent":["/*\n    A helper to define a lazily-loaded method.\n    It returns a function that, on the first call, imports the real implementation\n    and then caches it for all subsequent calls\n*/\nexport const defineLazyMethod = <\n  T extends object,\n  F extends (...args: any[]) => any,\n>(\n  target: T,\n  key: PropertyKey,\n  loader: () => Promise<F>\n): void => {\n  type R = Awaited<ReturnType<F>>;\n\n  let impl: F | undefined;\n  let loading: Promise<F> | undefined;\n\n  const install = (fn: F) => {\n    impl = fn;\n\n    // Replace the property with the resolved function so we skip the getter forever after\n    Object.defineProperty(target, key, {\n      configurable: true,\n      enumerable: true,\n      writable: false,\n      value: fn,\n    });\n\n    return fn;\n  };\n\n  Object.defineProperty(target, key, {\n    configurable: true,\n    enumerable: true,\n    get() {\n      // The first time someone *reads* the property, we return a callable proxy\n      const proxy = (...args: Parameters<F>): Promise<R> => {\n        if (impl) {\n          // Wrap in Promise.resolve to normalize sync/async F\n          return Promise.resolve(impl(...args)) as Promise<R>;\n        }\n        loading ??= loader().then(install);\n        return loading.then((fn) => fn(...args)) as Promise<R>;\n      };\n\n      // Replace the getter with the proxy immediately, so future reads don't hit this getter again\n      Object.defineProperty(target, key, {\n        configurable: true,\n        enumerable: true,\n        writable: false,\n        value: proxy,\n      });\n\n      return proxy;\n    },\n  });\n};\n\n/*\n    A namespace proxy whose methods are lazily executed the first time you call them.\n    *I hate TypeScript*\n*/\nexport const defineLazyNamespace = <\n  TTarget extends object,\n  TNamespace extends object,\n>(\n  target: TTarget,\n  key: PropertyKey,\n  loader: () => Promise<TNamespace>\n): void => {\n  let ns: TNamespace | undefined;\n  let loading: Promise<TNamespace> | undefined;\n\n  const install = (impl: TNamespace) => {\n    ns = impl;\n    Object.defineProperty(target, key, {\n      configurable: true,\n      enumerable: true,\n      writable: false,\n      value: impl,\n    });\n    return impl;\n  };\n\n  // A proxy that defers to the resolved namespace methods\n  const proxy: TNamespace = new Proxy({} as TNamespace, {\n    get(_obj, prop: PropertyKey) {\n      // When you call helius.webhooks.someMethod(...),\n      // we ensure the namespace is loaded, then forward the call\n      return (...args: any[]) => {\n        if (ns) {\n          return (ns as any)[prop](...args);\n        }\n\n        loading ??= loader().then(install);\n        return loading.then((impl) => (impl as any)[prop](...args));\n      };\n    },\n  });\n\n  Object.defineProperty(target, key, {\n    configurable: true,\n    enumerable: true,\n    get() {\n      // Kick off loading on first *read*, but immediately return the proxy\n      loading ??= loader().then(install);\n\n      // Replace this getter so we don't run it again\n      Object.defineProperty(target, key, {\n        configurable: true,\n        enumerable: true,\n        writable: false,\n        value: proxy,\n      });\n      return proxy;\n    },\n  });\n};\n"],"names":[],"mappings":"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"}