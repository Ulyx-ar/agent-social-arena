import { generateKeyPairSigner, pipe, createTransactionMessage, setTransactionMessageFeePayer, setTransactionMessageLifetimeUsingBlockhash, appendTransactionMessageInstructions, signTransactionMessageWithSigners, getBase64EncodedWireTransaction } from '@solana/kit';
import { getCreateAccountInstruction } from '@solana-program/system';
import { getInitializeInstruction, getDelegateStakeInstruction } from '@solana-program/stake';
import { STAKE_STATE_LEN, STAKE_PROGRAM_ID, UNUSED_STAKE_CONFIG_ACC, SYSVAR_STAKE_HISTORY, SYSVAR_CLOCK, HELIUS_VALIDATOR_ID } from './types.js';

const makeCreateStakeTransaction = ({ rpc, }) => {
    return async (ownerSigner, amountSol) => {
        const rentExempt = await rpc
            .getMinimumBalanceForRentExemption(BigInt(STAKE_STATE_LEN))
            .send();
        const userLamports = BigInt(Math.round(amountSol * 1000000000));
        const lamports = rentExempt + userLamports;
        const stakeAccount = await generateKeyPairSigner();
        const createIx = getCreateAccountInstruction({
            payer: ownerSigner,
            newAccount: stakeAccount,
            lamports,
            space: BigInt(STAKE_STATE_LEN),
            programAddress: STAKE_PROGRAM_ID,
        });
        const initializeIx = getInitializeInstruction({
            stake: stakeAccount.address,
            arg0: { staker: ownerSigner.address, withdrawer: ownerSigner.address },
            arg1: { unixTimestamp: 0n, epoch: 0n, custodian: ownerSigner.address },
        });
        const delegateIx = getDelegateStakeInstruction({
            stake: stakeAccount.address,
            vote: HELIUS_VALIDATOR_ID,
            clockSysvar: SYSVAR_CLOCK,
            stakeHistory: SYSVAR_STAKE_HISTORY,
            unused: UNUSED_STAKE_CONFIG_ACC,
            stakeAuthority: ownerSigner,
        });
        const { value: blockheight } = await rpc.getLatestBlockhash().send();
        const msg = pipe(createTransactionMessage({ version: 0 }), (m) => setTransactionMessageFeePayer(ownerSigner.address, m), (m) => setTransactionMessageLifetimeUsingBlockhash(blockheight, m), (m) => appendTransactionMessageInstructions([createIx, initializeIx, delegateIx], m));
        const signedTx = await signTransactionMessageWithSigners(msg);
        const serializedTx = getBase64EncodedWireTransaction(signedTx);
        return {
            serializedTx,
            stakeAccountPubkey: stakeAccount.address,
        };
    };
};

export { makeCreateStakeTransaction };
//# sourceMappingURL=createStakeTransaction.js.map
