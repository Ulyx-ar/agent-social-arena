import { address } from '@solana/kit';
import { U64_MAX, STAKE_STATE_LEN } from './types.js';

const makeGetWithdrawableAmount = ({ rpc, }) => {
    return async (stakeAccount, includeRentExempt = false) => {
        const stakeAddr = typeof stakeAccount === "string" ? address(stakeAccount) : stakeAccount;
        const { value: accInfo } = await rpc
            .getAccountInfo(stakeAddr, { encoding: "jsonParsed" })
            .send();
        if (!accInfo)
            throw new Error("Stake account not found");
        const { lamports, data } = accInfo;
        const parsed = data?.parsed; // We know it's JSON parsed
        if (!parsed?.info?.meta) {
            throw new Error("Not a valid stake account");
        }
        const info = parsed.info;
        // Guard: must be stake OR just initialised; never delegated
        if (!info.stake && info.meta?.type !== "initialized") {
            throw new Error("Not a valid stake account");
        }
        const deactivationStr = info.stake?.delegation?.deactivationEpoch ?? U64_MAX.toString();
        const deactivationEpoch = BigInt(deactivationStr);
        const currentEpoch = BigInt((await rpc.getEpochInfo().send()).epoch);
        // If still active (not yet cooled down), return 0
        if (deactivationEpoch > currentEpoch)
            return 0;
        if (includeRentExempt)
            return Number(lamports);
        const rentExempt = await rpc
            .getMinimumBalanceForRentExemption(BigInt(STAKE_STATE_LEN))
            .send();
        const withdrawable = lamports > rentExempt ? lamports - rentExempt : 0n;
        return Number(withdrawable);
    };
};

export { makeGetWithdrawableAmount };
//# sourceMappingURL=getWithdrawableAmount.js.map
