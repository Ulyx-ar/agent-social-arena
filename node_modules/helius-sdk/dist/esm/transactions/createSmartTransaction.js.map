{"version":3,"file":"createSmartTransaction.js","sources":["../../../../src/transactions/createSmartTransaction.ts"],"sourcesContent":["import type {\n  BlockhashLifetime,\n  CreateSmartTxDeps,\n  CreateSmartTxInput,\n  CreateSmartTxResult,\n  SignedTx,\n} from \"./types\";\nimport type { Address, Instruction, TransactionSigner } from \"@solana/kit\";\n\nimport {\n  createTransactionMessage,\n  getBase64EncodedWireTransaction,\n  pipe,\n  prependTransactionMessageInstructions,\n  appendTransactionMessageInstructions,\n  setTransactionMessageFeePayerSigner,\n  setTransactionMessageLifetimeUsingBlockhash,\n  signTransactionMessageWithSigners,\n} from \"@solana/kit\";\n\nimport {\n  getSetComputeUnitLimitInstruction,\n  getSetComputeUnitPriceInstruction,\n} from \"@solana-program/compute-budget\";\n\nconst COMPUTE_BUDGET_PROGRAM_ADDRESS =\n  \"ComputeBudget111111111111111111111111111111\" as Address;\n\nconst isComputeBudgetIx = (ix: Instruction<string, readonly any[]>) =>\n  ix.programAddress === COMPUTE_BUDGET_PROGRAM_ADDRESS;\n\nconst firstSigner = (\n  signers: readonly TransactionSigner<string>[]\n): TransactionSigner<string> => {\n  if (!signers.length)\n    throw new Error(\"createSmartTransaction: expected at least one signer.\");\n  return signers[0];\n};\n\nconst resolveFeePayerSigner = (\n  signers: readonly TransactionSigner<string>[],\n  feePayer?: CreateSmartTxInput[\"feePayer\"]\n): TransactionSigner<string> => {\n  if (!feePayer) return firstSigner(signers);\n\n  if (typeof feePayer !== \"string\") {\n    // Already a TransactionSigner\n    return feePayer as TransactionSigner<string>;\n  }\n\n  // Fee payer is an Address — find matching signer\n  const s = signers.find((s) => s.address === feePayer);\n\n  if (!s) {\n    throw new Error(\n      `createSmartTransaction: feePayer address (${feePayer}) was provided but no matching TransactionSigner found in 'signers'.`\n    );\n  }\n\n  return s;\n};\n\nexport const makeCreateSmartTransaction = ({\n  raw,\n  getComputeUnits,\n  getPriorityFeeEstimate,\n}: CreateSmartTxDeps) => {\n  const create = async ({\n    signers,\n    instructions,\n    version = 0,\n    priorityFeeCap,\n    minUnits = 1_000,\n    bufferPct = 0.1,\n    commitment = \"confirmed\",\n    feePayer,\n  }: CreateSmartTxInput): Promise<CreateSmartTxResult> => {\n    const feePayerSigner = resolveFeePayerSigner(signers, feePayer);\n    const userIxs = instructions.filter((ix) => !isComputeBudgetIx(ix));\n\n    // Draft message for CU estimation & fee sampling\n    const { value: initialLifetime } = await raw\n      .getLatestBlockhash({ commitment })\n      .send();\n\n    const draftMsg = pipe(\n      createTransactionMessage({ version }),\n      (m) => setTransactionMessageFeePayerSigner(feePayerSigner, m),\n      (m) => setTransactionMessageLifetimeUsingBlockhash(initialLifetime, m),\n      (m) => appendTransactionMessageInstructions(userIxs, m)\n    );\n\n    // Estimate compute units with floor + buffer\n    const units = await getComputeUnits(draftMsg, { min: minUnits, bufferPct });\n\n    // Sign the draft and get recommended fees\n    const draftSigned = await signTransactionMessageWithSigners(draftMsg);\n    const draftBase64 = getBase64EncodedWireTransaction(draftSigned);\n\n    const { priorityFeeEstimate } = await getPriorityFeeEstimate({\n      transaction: draftBase64,\n      options: { transactionEncoding: \"base64\", recommended: true },\n    });\n\n    if (priorityFeeEstimate == null) {\n      throw new Error(\n        \"Priority fee estimate not available. Error creating smart transaction.\"\n      );\n    }\n\n    const priorityFee =\n      priorityFeeCap != null\n        ? Math.min(priorityFeeEstimate, priorityFeeCap)\n        : priorityFeeEstimate;\n\n    // Refresh blockhash to avoid expiry window\n    const { value: finalLifetime } = await raw\n      .getLatestBlockhash({ commitment })\n      .send();\n\n    // Build the final message (fee payer → lifetime → compute budget → user ixs)\n    const finalMsg = pipe(\n      createTransactionMessage({ version }),\n      (m) => setTransactionMessageFeePayerSigner(feePayerSigner, m),\n      (m) => setTransactionMessageLifetimeUsingBlockhash(finalLifetime, m),\n      (m) =>\n        prependTransactionMessageInstructions(\n          [\n            getSetComputeUnitPriceInstruction({\n              microLamports: Number(priorityFee),\n            }),\n            getSetComputeUnitLimitInstruction({ units: Number(units) }),\n          ] as const,\n          m\n        ),\n      (m) => appendTransactionMessageInstructions(userIxs, m)\n    );\n\n    // Final sign & return\n    const finalSigned = await signTransactionMessageWithSigners(finalMsg);\n    const base64 = getBase64EncodedWireTransaction(finalSigned);\n\n    return {\n      signed: finalSigned as SignedTx,\n      base64,\n      units: Number(units),\n      priorityFee: Number(priorityFee),\n      lifetime: finalLifetime as BlockhashLifetime,\n      message: finalMsg,\n    };\n  };\n\n  return { create };\n};\n"],"names":[],"mappings":"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"}